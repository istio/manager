// Code generated by protoc-gen-go.
// source: cfg.proto
// DO NOT EDIT!

/*
Package config is a generated protocol buffer package.

It is generated from these files:
	cfg.proto

It has these top-level messages:
	ProxyMeshConfig
	Destination
	RouteRule
	MatchCondition
	DestinationWeight
	L4MatchAttributes
	StringMatch
	LoadBalancing
	HTTPTimeout
	HTTPRetry
	CircuitBreaker
	HTTPFaultInjection
	L4FaultInjection
*/
package config

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"
import google_protobuf1 "github.com/golang/protobuf/ptypes/wrappers"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type LoadBalancing_SimpleLBPolicy int32

const (
	// These four simple load balancing policies have literally no
	// additional configuration.
	LoadBalancing_ROUND_ROBIN LoadBalancing_SimpleLBPolicy = 0
	LoadBalancing_LEAST_CONN  LoadBalancing_SimpleLBPolicy = 1
	LoadBalancing_RANDOM      LoadBalancing_SimpleLBPolicy = 3
)

var LoadBalancing_SimpleLBPolicy_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_CONN",
	3: "RANDOM",
}
var LoadBalancing_SimpleLBPolicy_value = map[string]int32{
	"ROUND_ROBIN": 0,
	"LEAST_CONN":  1,
	"RANDOM":      3,
}

func (x LoadBalancing_SimpleLBPolicy) String() string {
	return proto.EnumName(LoadBalancing_SimpleLBPolicy_name, int32(x))
}
func (LoadBalancing_SimpleLBPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 0}
}

// Proxy level global configurations go here
type ProxyMeshConfig struct {
}

func (m *ProxyMeshConfig) Reset()                    { *m = ProxyMeshConfig{} }
func (m *ProxyMeshConfig) String() string            { return proto.CompactTextString(m) }
func (*ProxyMeshConfig) ProtoMessage()               {}
func (*ProxyMeshConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Destination declares policies that determine how to handle traffic for a
// destination service (load balancing policies, failure recovery policies such
// as timeouts, retries, circuit breakers, etc).  Policies are applicable per
// individual service versions. It is an error to define multiple policies for
// the same service version.
//
// N.B. The policies are enforced on client-side connections or requests, i.e.,
// enforced when the service is opening a connection/sending a request via the
// proxy to the destination.
type Destination struct {
	// Service name for which the service version is defined.
	// The name should be fully-qualified, e.g. "my-service.default.svc.cluster.local".
	Destination string `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	// Service version destination identifier for the destination service.
	// The identifier is qualified by the destination service name, e.g. version
	// "env=prod" in "my-service.default.svc.cluster.local".
	//
	// N.B. The map is used instead of pstruct due to lack of serialization support
	// in golang protobuf library (see https://github.com/golang/protobuf/pull/208)
	Tags map[string]string `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Load balancing policy
	LoadBalancing *LoadBalancing `protobuf:"bytes,3,opt,name=load_balancing,json=loadBalancing" json:"load_balancing,omitempty"`
	// Circuit breaker policy
	CircuitBreaker *CircuitBreaker `protobuf:"bytes,4,opt,name=circuit_breaker,json=circuitBreaker" json:"circuit_breaker,omitempty"`
	// Timeout policy. N.B. Applicable to the default service version only.
	HttpTimeout *HTTPTimeout `protobuf:"bytes,5,opt,name=http_timeout,json=httpTimeout" json:"http_timeout,omitempty"`
	// Retry policy. N.B. Applicable to the default service version only.
	HttpRetry *HTTPRetry `protobuf:"bytes,6,opt,name=http_retry,json=httpRetry" json:"http_retry,omitempty"`
	// L7 fault injection policy applies to L7 traffic
	HttpFault *HTTPFaultInjection `protobuf:"bytes,7,opt,name=http_fault,json=httpFault" json:"http_fault,omitempty"`
	// L4 fault injection policy applies to L4 traffic
	L4Fault *L4FaultInjection `protobuf:"bytes,8,opt,name=l4_fault,json=l4Fault" json:"l4_fault,omitempty"`
	// Custom policy implementations
	Custom *google_protobuf.Any `protobuf:"bytes,9,opt,name=custom" json:"custom,omitempty"`
}

func (m *Destination) Reset()                    { *m = Destination{} }
func (m *Destination) String() string            { return proto.CompactTextString(m) }
func (*Destination) ProtoMessage()               {}
func (*Destination) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Destination) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Destination) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Destination) GetLoadBalancing() *LoadBalancing {
	if m != nil {
		return m.LoadBalancing
	}
	return nil
}

func (m *Destination) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

func (m *Destination) GetHttpTimeout() *HTTPTimeout {
	if m != nil {
		return m.HttpTimeout
	}
	return nil
}

func (m *Destination) GetHttpRetry() *HTTPRetry {
	if m != nil {
		return m.HttpRetry
	}
	return nil
}

func (m *Destination) GetHttpFault() *HTTPFaultInjection {
	if m != nil {
		return m.HttpFault
	}
	return nil
}

func (m *Destination) GetL4Fault() *L4FaultInjection {
	if m != nil {
		return m.L4Fault
	}
	return nil
}

func (m *Destination) GetCustom() *google_protobuf.Any {
	if m != nil {
		return m.Custom
	}
	return nil
}

// Route rule provides a custom routing policy based on the source and
// destination service versions and connection/request metadata.  The rule must
// provide a set of conditions for each protocol (TCP, UDP, HTTP) that the
// destination service exposes on its ports. The rule applies only to the ports
// on the destination service for which it provides protocol-specific match
// condition, e.g. if the rule does not specify TCP condition, the rule does
// not apply to TCP traffic towards the destination service.
type RouteRule struct {
	// Uniquely identifies the destination  associated with this routing rule.
	// This is applicable for hostname-based resolution for HTTP traffic as well as
	// IP-based resolution for TCP/UDP traffic.
	//
	// The value is either the fully qualified service name or the cluster subdomain
	// with the interpretation that the cluster route rule applies to its ingress traffic.
	// For example, "my-service.default.svc.cluster.local" refers to a service by its
	// name, while "svc.cluster.local" refers to the cluster ingress traffic.
	//
	// The destination field is mandatory for each route rule.
	//
	// Examples: "my-service.default.svc.cluster.local", "svc.cluster.local".
	Destination string `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	// Match condition is optional.
	// By default, the rule applies to HTTP traffic only.
	Match *MatchCondition `protobuf:"bytes,2,opt,name=match" json:"match,omitempty"`
	// Each routing rule is associated with one or more service version destinations
	// (see glossary in beginning of document). Weights associated with the service
	// version determine the proportion of traffic it receives.
	Route []*DestinationWeight `protobuf:"bytes,3,rep,name=route" json:"route,omitempty"`
	// Precedence is used to disambiguate the order of application of rules for
	// the same destination service. A higher number takes priority.  If not
	// specified, the value is assumed to be 0.  The order of application for rules
	// with the same precedence is unspecified.
	//
	// Rule precedence can be used to order routes for a single destination, as
	// well as override existing routes with the same attribute condition.
	Precedence int32 `protobuf:"varint,4,opt,name=precedence" json:"precedence,omitempty"`
}

func (m *RouteRule) Reset()                    { *m = RouteRule{} }
func (m *RouteRule) String() string            { return proto.CompactTextString(m) }
func (*RouteRule) ProtoMessage()               {}
func (*RouteRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RouteRule) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *RouteRule) GetMatch() *MatchCondition {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *RouteRule) GetRoute() []*DestinationWeight {
	if m != nil {
		return m.Route
	}
	return nil
}

func (m *RouteRule) GetPrecedence() int32 {
	if m != nil {
		return m.Precedence
	}
	return 0
}

// Match condition selects traffic for routing application.
// The condition provides distinct set of conditions for each protocol with the
// intention that conditions apply only to the service ports that match the protocol.
type MatchCondition struct {
	// Identifies the service initiating a connection or a request by its name.
	Source string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Identifies the source service version. The identifier is interpreted
	// by the platform to match a service version for the source service.
	//
	// N.B. The map is used instead of pstruct due to lack of serialization support
	// in golang protobuf library (see https://github.com/golang/protobuf/pull/208)
	SourceTags map[string]string `protobuf:"bytes,2,rep,name=source_tags,json=sourceTags" json:"source_tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Set of layer 4 match conditions based on the IP ranges
	Tcp *L4MatchAttributes `protobuf:"bytes,3,opt,name=tcp" json:"tcp,omitempty"`
	// Set of layer 4 match conditions based on the IP ranges
	Udp *L4MatchAttributes `protobuf:"bytes,4,opt,name=udp" json:"udp,omitempty"`
	// Set of HTTP match conditions based on HTTP/1.1, HTTP/2, GRPC request metadata,
	// such as "uri", "scheme", "authority".
	// The header keys are case-insensitive.
	Http map[string]*StringMatch `protobuf:"bytes,5,rep,name=http" json:"http,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MatchCondition) Reset()                    { *m = MatchCondition{} }
func (m *MatchCondition) String() string            { return proto.CompactTextString(m) }
func (*MatchCondition) ProtoMessage()               {}
func (*MatchCondition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *MatchCondition) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *MatchCondition) GetSourceTags() map[string]string {
	if m != nil {
		return m.SourceTags
	}
	return nil
}

func (m *MatchCondition) GetTcp() *L4MatchAttributes {
	if m != nil {
		return m.Tcp
	}
	return nil
}

func (m *MatchCondition) GetUdp() *L4MatchAttributes {
	if m != nil {
		return m.Udp
	}
	return nil
}

func (m *MatchCondition) GetHttp() map[string]*StringMatch {
	if m != nil {
		return m.Http
	}
	return nil
}

// Each routing rule is associated with one or more service versions (see
// glossary in beginning of document). Weights associated with the version
// determine the proportion of traffic it receives.
type DestinationWeight struct {
	// Uniquely identifies the destination service.
	// If not specified, the value is inherited from the parent route rule.
	//
	// Example: "my-service.default.svc.cluster.local".
	Destination string `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	// Service version identifier for the destination service.
	//
	// N.B. The map is used instead of pstruct due to lack of serialization support
	// in golang protobuf library (see https://github.com/golang/protobuf/pull/208)
	Tags map[string]string `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The proportion of traffic to be forwarded to the service version Max is
	// 100. Sum of weights across destinations should add up to 100.
	// If there is only destination in a rule, the weight value is assumed to be 100.
	Weight int32 `protobuf:"varint,3,opt,name=weight" json:"weight,omitempty"`
}

func (m *DestinationWeight) Reset()                    { *m = DestinationWeight{} }
func (m *DestinationWeight) String() string            { return proto.CompactTextString(m) }
func (*DestinationWeight) ProtoMessage()               {}
func (*DestinationWeight) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DestinationWeight) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *DestinationWeight) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DestinationWeight) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// L4 connection match attributes
type L4MatchAttributes struct {
	// IPv4 or IPv6 ip address with optional subnet. E.g., a.b.c.d/xx form or
	// just a.b.c.d
	SourceSubnet []string `protobuf:"bytes,1,rep,name=source_subnet,json=sourceSubnet" json:"source_subnet,omitempty"`
	// IPv4 or IPv6 ip address with optional subnet. E.g., a.b.c.d/xx form or
	// just a.b.c.d
	DestinationSubnet []string `protobuf:"bytes,2,rep,name=destination_subnet,json=destinationSubnet" json:"destination_subnet,omitempty"`
}

func (m *L4MatchAttributes) Reset()                    { *m = L4MatchAttributes{} }
func (m *L4MatchAttributes) String() string            { return proto.CompactTextString(m) }
func (*L4MatchAttributes) ProtoMessage()               {}
func (*L4MatchAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *L4MatchAttributes) GetSourceSubnet() []string {
	if m != nil {
		return m.SourceSubnet
	}
	return nil
}

func (m *L4MatchAttributes) GetDestinationSubnet() []string {
	if m != nil {
		return m.DestinationSubnet
	}
	return nil
}

// Describes how to matches a given string (exact match, prefix-based match
// or posix style regex based match). Match is case-sensitive.
// It is a validation error to supply a regex for a proxy that does not support it.
type StringMatch struct {
	// Types that are valid to be assigned to MatchType:
	//	*StringMatch_Exact
	//	*StringMatch_Prefix
	//	*StringMatch_Regex
	MatchType isStringMatch_MatchType `protobuf_oneof:"match_type"`
}

func (m *StringMatch) Reset()                    { *m = StringMatch{} }
func (m *StringMatch) String() string            { return proto.CompactTextString(m) }
func (*StringMatch) ProtoMessage()               {}
func (*StringMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isStringMatch_MatchType interface {
	isStringMatch_MatchType()
}

type StringMatch_Exact struct {
	Exact string `protobuf:"bytes,1,opt,name=exact,oneof"`
}
type StringMatch_Prefix struct {
	Prefix string `protobuf:"bytes,2,opt,name=prefix,oneof"`
}
type StringMatch_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,oneof"`
}

func (*StringMatch_Exact) isStringMatch_MatchType()  {}
func (*StringMatch_Prefix) isStringMatch_MatchType() {}
func (*StringMatch_Regex) isStringMatch_MatchType()  {}

func (m *StringMatch) GetMatchType() isStringMatch_MatchType {
	if m != nil {
		return m.MatchType
	}
	return nil
}

func (m *StringMatch) GetExact() string {
	if x, ok := m.GetMatchType().(*StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *StringMatch) GetPrefix() string {
	if x, ok := m.GetMatchType().(*StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *StringMatch) GetRegex() string {
	if x, ok := m.GetMatchType().(*StringMatch_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StringMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StringMatch_OneofMarshaler, _StringMatch_OneofUnmarshaler, _StringMatch_OneofSizer, []interface{}{
		(*StringMatch_Exact)(nil),
		(*StringMatch_Prefix)(nil),
		(*StringMatch_Regex)(nil),
	}
}

func _StringMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Exact)
	case *StringMatch_Prefix:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Prefix)
	case *StringMatch_Regex:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Regex)
	case nil:
	default:
		return fmt.Errorf("StringMatch.MatchType has unexpected type %T", x)
	}
	return nil
}

func _StringMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StringMatch)
	switch tag {
	case 1: // match_type.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Exact{x}
		return true, err
	case 2: // match_type.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Prefix{x}
		return true, err
	case 3: // match_type.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Regex{x}
		return true, err
	default:
		return false, nil
	}
}

func _StringMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *StringMatch_Prefix:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case *StringMatch_Regex:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Load balancing policy to use when forwarding traffic.
type LoadBalancing struct {
	// Types that are valid to be assigned to LbPolicy:
	//	*LoadBalancing_Name
	//	*LoadBalancing_Custom
	LbPolicy isLoadBalancing_LbPolicy `protobuf_oneof:"lb_policy"`
}

func (m *LoadBalancing) Reset()                    { *m = LoadBalancing{} }
func (m *LoadBalancing) String() string            { return proto.CompactTextString(m) }
func (*LoadBalancing) ProtoMessage()               {}
func (*LoadBalancing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isLoadBalancing_LbPolicy interface {
	isLoadBalancing_LbPolicy()
}

type LoadBalancing_Name struct {
	Name LoadBalancing_SimpleLBPolicy `protobuf:"varint,1,opt,name=name,enum=istio.proxy.v1alpha.config.LoadBalancing_SimpleLBPolicy,oneof"`
}
type LoadBalancing_Custom struct {
	Custom *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom,oneof"`
}

func (*LoadBalancing_Name) isLoadBalancing_LbPolicy()   {}
func (*LoadBalancing_Custom) isLoadBalancing_LbPolicy() {}

func (m *LoadBalancing) GetLbPolicy() isLoadBalancing_LbPolicy {
	if m != nil {
		return m.LbPolicy
	}
	return nil
}

func (m *LoadBalancing) GetName() LoadBalancing_SimpleLBPolicy {
	if x, ok := m.GetLbPolicy().(*LoadBalancing_Name); ok {
		return x.Name
	}
	return LoadBalancing_ROUND_ROBIN
}

func (m *LoadBalancing) GetCustom() *google_protobuf.Any {
	if x, ok := m.GetLbPolicy().(*LoadBalancing_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LoadBalancing) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LoadBalancing_OneofMarshaler, _LoadBalancing_OneofUnmarshaler, _LoadBalancing_OneofSizer, []interface{}{
		(*LoadBalancing_Name)(nil),
		(*LoadBalancing_Custom)(nil),
	}
}

func _LoadBalancing_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LoadBalancing)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancing_Name:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Name))
	case *LoadBalancing_Custom:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Custom); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LoadBalancing.LbPolicy has unexpected type %T", x)
	}
	return nil
}

func _LoadBalancing_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LoadBalancing)
	switch tag {
	case 1: // lb_policy.name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.LbPolicy = &LoadBalancing_Name{LoadBalancing_SimpleLBPolicy(x)}
		return true, err
	case 2: // lb_policy.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.LbPolicy = &LoadBalancing_Custom{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LoadBalancing_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LoadBalancing)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancing_Name:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Name))
	case *LoadBalancing_Custom:
		s := proto.Size(x.Custom)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request timeout: wait time until a response is received. Does not
// indicate the time for the entire response to arrive.
type HTTPTimeout struct {
	// Types that are valid to be assigned to TimeoutPolicy:
	//	*HTTPTimeout_SimpleTimeout
	//	*HTTPTimeout_Custom
	TimeoutPolicy isHTTPTimeout_TimeoutPolicy `protobuf_oneof:"timeout_policy"`
}

func (m *HTTPTimeout) Reset()                    { *m = HTTPTimeout{} }
func (m *HTTPTimeout) String() string            { return proto.CompactTextString(m) }
func (*HTTPTimeout) ProtoMessage()               {}
func (*HTTPTimeout) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isHTTPTimeout_TimeoutPolicy interface {
	isHTTPTimeout_TimeoutPolicy()
}

type HTTPTimeout_SimpleTimeout struct {
	SimpleTimeout *HTTPTimeout_SimpleTimeoutPolicy `protobuf:"bytes,1,opt,name=simple_timeout,json=simpleTimeout,oneof"`
}
type HTTPTimeout_Custom struct {
	Custom *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom,oneof"`
}

func (*HTTPTimeout_SimpleTimeout) isHTTPTimeout_TimeoutPolicy() {}
func (*HTTPTimeout_Custom) isHTTPTimeout_TimeoutPolicy()        {}

func (m *HTTPTimeout) GetTimeoutPolicy() isHTTPTimeout_TimeoutPolicy {
	if m != nil {
		return m.TimeoutPolicy
	}
	return nil
}

func (m *HTTPTimeout) GetSimpleTimeout() *HTTPTimeout_SimpleTimeoutPolicy {
	if x, ok := m.GetTimeoutPolicy().(*HTTPTimeout_SimpleTimeout); ok {
		return x.SimpleTimeout
	}
	return nil
}

func (m *HTTPTimeout) GetCustom() *google_protobuf.Any {
	if x, ok := m.GetTimeoutPolicy().(*HTTPTimeout_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HTTPTimeout) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HTTPTimeout_OneofMarshaler, _HTTPTimeout_OneofUnmarshaler, _HTTPTimeout_OneofSizer, []interface{}{
		(*HTTPTimeout_SimpleTimeout)(nil),
		(*HTTPTimeout_Custom)(nil),
	}
}

func _HTTPTimeout_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HTTPTimeout)
	// timeout_policy
	switch x := m.TimeoutPolicy.(type) {
	case *HTTPTimeout_SimpleTimeout:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleTimeout); err != nil {
			return err
		}
	case *HTTPTimeout_Custom:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Custom); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HTTPTimeout.TimeoutPolicy has unexpected type %T", x)
	}
	return nil
}

func _HTTPTimeout_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HTTPTimeout)
	switch tag {
	case 1: // timeout_policy.simple_timeout
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HTTPTimeout_SimpleTimeoutPolicy)
		err := b.DecodeMessage(msg)
		m.TimeoutPolicy = &HTTPTimeout_SimpleTimeout{msg}
		return true, err
	case 2: // timeout_policy.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.TimeoutPolicy = &HTTPTimeout_Custom{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HTTPTimeout_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HTTPTimeout)
	// timeout_policy
	switch x := m.TimeoutPolicy.(type) {
	case *HTTPTimeout_SimpleTimeout:
		s := proto.Size(x.SimpleTimeout)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HTTPTimeout_Custom:
		s := proto.Size(x.Custom)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HTTPTimeout_SimpleTimeoutPolicy struct {
	// timeout is per attempt, when retries are specified as well.
	// seconds.nanoseconds format
	TimeoutSeconds float64 `protobuf:"fixed64,1,opt,name=timeout_seconds,json=timeoutSeconds" json:"timeout_seconds,omitempty"`
	// Downstream service could specify timeout via Http header to the
	// proxy, if the proxy supports such a feature.
	OverrideHeaderName string `protobuf:"bytes,2,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HTTPTimeout_SimpleTimeoutPolicy) Reset()         { *m = HTTPTimeout_SimpleTimeoutPolicy{} }
func (m *HTTPTimeout_SimpleTimeoutPolicy) String() string { return proto.CompactTextString(m) }
func (*HTTPTimeout_SimpleTimeoutPolicy) ProtoMessage()    {}
func (*HTTPTimeout_SimpleTimeoutPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{8, 0}
}

func (m *HTTPTimeout_SimpleTimeoutPolicy) GetTimeoutSeconds() float64 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

func (m *HTTPTimeout_SimpleTimeoutPolicy) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// Retry policy to use when a request fails.
type HTTPRetry struct {
	// Types that are valid to be assigned to RetryPolicy:
	//	*HTTPRetry_SimpleRetry
	//	*HTTPRetry_Custom
	RetryPolicy isHTTPRetry_RetryPolicy `protobuf_oneof:"retry_policy"`
}

func (m *HTTPRetry) Reset()                    { *m = HTTPRetry{} }
func (m *HTTPRetry) String() string            { return proto.CompactTextString(m) }
func (*HTTPRetry) ProtoMessage()               {}
func (*HTTPRetry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isHTTPRetry_RetryPolicy interface {
	isHTTPRetry_RetryPolicy()
}

type HTTPRetry_SimpleRetry struct {
	SimpleRetry *HTTPRetry_SimpleRetryPolicy `protobuf:"bytes,1,opt,name=simple_retry,json=simpleRetry,oneof"`
}
type HTTPRetry_Custom struct {
	Custom *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom,oneof"`
}

func (*HTTPRetry_SimpleRetry) isHTTPRetry_RetryPolicy() {}
func (*HTTPRetry_Custom) isHTTPRetry_RetryPolicy()      {}

func (m *HTTPRetry) GetRetryPolicy() isHTTPRetry_RetryPolicy {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *HTTPRetry) GetSimpleRetry() *HTTPRetry_SimpleRetryPolicy {
	if x, ok := m.GetRetryPolicy().(*HTTPRetry_SimpleRetry); ok {
		return x.SimpleRetry
	}
	return nil
}

func (m *HTTPRetry) GetCustom() *google_protobuf.Any {
	if x, ok := m.GetRetryPolicy().(*HTTPRetry_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HTTPRetry) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HTTPRetry_OneofMarshaler, _HTTPRetry_OneofUnmarshaler, _HTTPRetry_OneofSizer, []interface{}{
		(*HTTPRetry_SimpleRetry)(nil),
		(*HTTPRetry_Custom)(nil),
	}
}

func _HTTPRetry_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HTTPRetry)
	// retry_policy
	switch x := m.RetryPolicy.(type) {
	case *HTTPRetry_SimpleRetry:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleRetry); err != nil {
			return err
		}
	case *HTTPRetry_Custom:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Custom); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HTTPRetry.RetryPolicy has unexpected type %T", x)
	}
	return nil
}

func _HTTPRetry_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HTTPRetry)
	switch tag {
	case 1: // retry_policy.simple_retry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HTTPRetry_SimpleRetryPolicy)
		err := b.DecodeMessage(msg)
		m.RetryPolicy = &HTTPRetry_SimpleRetry{msg}
		return true, err
	case 2: // retry_policy.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.RetryPolicy = &HTTPRetry_Custom{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HTTPRetry_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HTTPRetry)
	// retry_policy
	switch x := m.RetryPolicy.(type) {
	case *HTTPRetry_SimpleRetry:
		s := proto.Size(x.SimpleRetry)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HTTPRetry_Custom:
		s := proto.Size(x.Custom)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HTTPRetry_SimpleRetryPolicy struct {
	// number of times the request should be retried.
	// total timeout would be attempts * timeout
	Attempts int32 `protobuf:"varint,1,opt,name=attempts" json:"attempts,omitempty"`
	// Downstream Service could specify retry attempts via Http header to
	// the proxy, if the proxy supports such a feature.
	OverrideHeaderName string `protobuf:"bytes,2,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HTTPRetry_SimpleRetryPolicy) Reset()                    { *m = HTTPRetry_SimpleRetryPolicy{} }
func (m *HTTPRetry_SimpleRetryPolicy) String() string            { return proto.CompactTextString(m) }
func (*HTTPRetry_SimpleRetryPolicy) ProtoMessage()               {}
func (*HTTPRetry_SimpleRetryPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *HTTPRetry_SimpleRetryPolicy) GetAttempts() int32 {
	if m != nil {
		return m.Attempts
	}
	return 0
}

func (m *HTTPRetry_SimpleRetryPolicy) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// TODO(rshriram) add all Envoy CB capabilities
// A minimal circuit breaker configuration.
type CircuitBreaker struct {
	// Types that are valid to be assigned to CbPolicy:
	//	*CircuitBreaker_SimpleCb
	//	*CircuitBreaker_Custom
	CbPolicy isCircuitBreaker_CbPolicy `protobuf_oneof:"cb_policy"`
}

func (m *CircuitBreaker) Reset()                    { *m = CircuitBreaker{} }
func (m *CircuitBreaker) String() string            { return proto.CompactTextString(m) }
func (*CircuitBreaker) ProtoMessage()               {}
func (*CircuitBreaker) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isCircuitBreaker_CbPolicy interface {
	isCircuitBreaker_CbPolicy()
}

type CircuitBreaker_SimpleCb struct {
	SimpleCb *CircuitBreaker_SimpleCircuitBreakerPolicy `protobuf:"bytes,1,opt,name=simple_cb,json=simpleCb,oneof"`
}
type CircuitBreaker_Custom struct {
	Custom *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom,oneof"`
}

func (*CircuitBreaker_SimpleCb) isCircuitBreaker_CbPolicy() {}
func (*CircuitBreaker_Custom) isCircuitBreaker_CbPolicy()   {}

func (m *CircuitBreaker) GetCbPolicy() isCircuitBreaker_CbPolicy {
	if m != nil {
		return m.CbPolicy
	}
	return nil
}

func (m *CircuitBreaker) GetSimpleCb() *CircuitBreaker_SimpleCircuitBreakerPolicy {
	if x, ok := m.GetCbPolicy().(*CircuitBreaker_SimpleCb); ok {
		return x.SimpleCb
	}
	return nil
}

func (m *CircuitBreaker) GetCustom() *google_protobuf.Any {
	if x, ok := m.GetCbPolicy().(*CircuitBreaker_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CircuitBreaker) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CircuitBreaker_OneofMarshaler, _CircuitBreaker_OneofUnmarshaler, _CircuitBreaker_OneofSizer, []interface{}{
		(*CircuitBreaker_SimpleCb)(nil),
		(*CircuitBreaker_Custom)(nil),
	}
}

func _CircuitBreaker_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CircuitBreaker)
	// cb_policy
	switch x := m.CbPolicy.(type) {
	case *CircuitBreaker_SimpleCb:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleCb); err != nil {
			return err
		}
	case *CircuitBreaker_Custom:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Custom); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CircuitBreaker.CbPolicy has unexpected type %T", x)
	}
	return nil
}

func _CircuitBreaker_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CircuitBreaker)
	switch tag {
	case 1: // cb_policy.simple_cb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CircuitBreaker_SimpleCircuitBreakerPolicy)
		err := b.DecodeMessage(msg)
		m.CbPolicy = &CircuitBreaker_SimpleCb{msg}
		return true, err
	case 2: // cb_policy.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.CbPolicy = &CircuitBreaker_Custom{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CircuitBreaker_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CircuitBreaker)
	// cb_policy
	switch x := m.CbPolicy.(type) {
	case *CircuitBreaker_SimpleCb:
		s := proto.Size(x.SimpleCb)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CircuitBreaker_Custom:
		s := proto.Size(x.Custom)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CircuitBreaker_SimpleCircuitBreakerPolicy struct {
	// (for an unhealthy upstream) number of consecutive requests that
	// should succeed before the upstream is marked healthy.
	SuccessThreshold int32 `protobuf:"varint,1,opt,name=success_threshold,json=successThreshold" json:"success_threshold,omitempty"`
	// (for a healthy upstream) number of consecutive requests that
	// can fail before the upstream is marked unhealthy.
	FailureThreshold int32 `protobuf:"varint,2,opt,name=failure_threshold,json=failureThreshold" json:"failure_threshold,omitempty"`
	// When a healthy upstream becomes unhealthy, duration to wait before
	// attempting to send requests to that upstream.
	// format seconds.nanoseconds
	ResetTimeoutSeconds float64 `protobuf:"fixed64,3,opt,name=reset_timeout_seconds,json=resetTimeoutSeconds" json:"reset_timeout_seconds,omitempty"`
	// Maximum number of connections to a backend.
	MaxConnections int32 `protobuf:"varint,4,opt,name=max_connections,json=maxConnections" json:"max_connections,omitempty"`
	// Maximum number of pending requests to a backend.
	HttpMaxPendingRequests int32 `protobuf:"varint,5,opt,name=http_max_pending_requests,json=httpMaxPendingRequests" json:"http_max_pending_requests,omitempty"`
	// Maximum number of requests to a backend.
	HttpMaxRequests int32 `protobuf:"varint,6,opt,name=http_max_requests,json=httpMaxRequests" json:"http_max_requests,omitempty"`
	// Minimum time the circuit will be closed.
	SleepWindow string `protobuf:"bytes,7,opt,name=sleep_window,json=sleepWindow" json:"sleep_window,omitempty"`
	// Number of 5XX errors before circuit is opened.
	HttpConsecutiveErrors int32 `protobuf:"varint,8,opt,name=http_consecutive_errors,json=httpConsecutiveErrors" json:"http_consecutive_errors,omitempty"`
	// Interval for checking state of hystrix circuit.
	HttpDetectionInterval int32 `protobuf:"varint,9,opt,name=http_detection_interval,json=httpDetectionInterval" json:"http_detection_interval,omitempty"`
	// Maximum number of requests per connection to a backend.
	HttpMaxRequestsPerConnection int32 `protobuf:"varint,10,opt,name=http_max_requests_per_connection,json=httpMaxRequestsPerConnection" json:"http_max_requests_per_connection,omitempty"`
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) Reset() {
	*m = CircuitBreaker_SimpleCircuitBreakerPolicy{}
}
func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) String() string { return proto.CompactTextString(m) }
func (*CircuitBreaker_SimpleCircuitBreakerPolicy) ProtoMessage()    {}
func (*CircuitBreaker_SimpleCircuitBreakerPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0}
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetSuccessThreshold() int32 {
	if m != nil {
		return m.SuccessThreshold
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetFailureThreshold() int32 {
	if m != nil {
		return m.FailureThreshold
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetResetTimeoutSeconds() float64 {
	if m != nil {
		return m.ResetTimeoutSeconds
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetMaxConnections() int32 {
	if m != nil {
		return m.MaxConnections
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpMaxPendingRequests() int32 {
	if m != nil {
		return m.HttpMaxPendingRequests
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpMaxRequests() int32 {
	if m != nil {
		return m.HttpMaxRequests
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetSleepWindow() string {
	if m != nil {
		return m.SleepWindow
	}
	return ""
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpConsecutiveErrors() int32 {
	if m != nil {
		return m.HttpConsecutiveErrors
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpDetectionInterval() int32 {
	if m != nil {
		return m.HttpDetectionInterval
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpMaxRequestsPerConnection() int32 {
	if m != nil {
		return m.HttpMaxRequestsPerConnection
	}
	return 0
}

// Faults can be injected into the API calls by the proxy, for testing the
// failure recovery capabilities of downstream services.  Faults include
// aborting the Http request from downstream service, delaying the proxying of
// requests, or both.
type HTTPFaultInjection struct {
	// Delay requests before forwarding, emulating various failures such as
	// network issues, overloaded upstream service, etc.
	Delay *HTTPFaultInjection_Delay `protobuf:"bytes,1,opt,name=delay" json:"delay,omitempty"`
	// Abort Http request attempts and return error codes back to downstream
	// service, giving the impression that the upstream service is faulty.
	// N.B. Both delay and abort can be specified simultaneously. Delay and
	// Abort are independent of one another. For e.g., if Delay is restricted
	// to 5% of requests while Abort is restricted to 10% of requests, the
	// 10% in abort specification applies to all requests directed to the
	// service. It may be the case that one or more requests being aborted
	// were also delayed.
	Abort *HTTPFaultInjection_Abort `protobuf:"bytes,2,opt,name=abort" json:"abort,omitempty"`
	// Only requests with these Http headers will be subjected to fault
	// injection
	Headers map[string]*StringMatch `protobuf:"bytes,3,rep,name=headers" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HTTPFaultInjection) Reset()                    { *m = HTTPFaultInjection{} }
func (m *HTTPFaultInjection) String() string            { return proto.CompactTextString(m) }
func (*HTTPFaultInjection) ProtoMessage()               {}
func (*HTTPFaultInjection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *HTTPFaultInjection) GetDelay() *HTTPFaultInjection_Delay {
	if m != nil {
		return m.Delay
	}
	return nil
}

func (m *HTTPFaultInjection) GetAbort() *HTTPFaultInjection_Abort {
	if m != nil {
		return m.Abort
	}
	return nil
}

func (m *HTTPFaultInjection) GetHeaders() map[string]*StringMatch {
	if m != nil {
		return m.Headers
	}
	return nil
}

// Either a fixed delay or exponential delay.
type HTTPFaultInjection_Delay struct {
	// Types that are valid to be assigned to HttpDelayType:
	//	*HTTPFaultInjection_Delay_FixedDelay
	//	*HTTPFaultInjection_Delay_ExpDelay
	HttpDelayType isHTTPFaultInjection_Delay_HttpDelayType `protobuf_oneof:"http_delay_type"`
	// Specify delay duration as part of Http request.
	// TODO: The semantics and syntax of the headers is undefined.
	OverrideHeaderName string `protobuf:"bytes,3,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HTTPFaultInjection_Delay) Reset()                    { *m = HTTPFaultInjection_Delay{} }
func (m *HTTPFaultInjection_Delay) String() string            { return proto.CompactTextString(m) }
func (*HTTPFaultInjection_Delay) ProtoMessage()               {}
func (*HTTPFaultInjection_Delay) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 1} }

type isHTTPFaultInjection_Delay_HttpDelayType interface {
	isHTTPFaultInjection_Delay_HttpDelayType()
}

type HTTPFaultInjection_Delay_FixedDelay struct {
	FixedDelay *HTTPFaultInjection_FixedDelay `protobuf:"bytes,1,opt,name=fixed_delay,json=fixedDelay,oneof"`
}
type HTTPFaultInjection_Delay_ExpDelay struct {
	ExpDelay *HTTPFaultInjection_ExponentialDelay `protobuf:"bytes,2,opt,name=exp_delay,json=expDelay,oneof"`
}

func (*HTTPFaultInjection_Delay_FixedDelay) isHTTPFaultInjection_Delay_HttpDelayType() {}
func (*HTTPFaultInjection_Delay_ExpDelay) isHTTPFaultInjection_Delay_HttpDelayType()   {}

func (m *HTTPFaultInjection_Delay) GetHttpDelayType() isHTTPFaultInjection_Delay_HttpDelayType {
	if m != nil {
		return m.HttpDelayType
	}
	return nil
}

func (m *HTTPFaultInjection_Delay) GetFixedDelay() *HTTPFaultInjection_FixedDelay {
	if x, ok := m.GetHttpDelayType().(*HTTPFaultInjection_Delay_FixedDelay); ok {
		return x.FixedDelay
	}
	return nil
}

func (m *HTTPFaultInjection_Delay) GetExpDelay() *HTTPFaultInjection_ExponentialDelay {
	if x, ok := m.GetHttpDelayType().(*HTTPFaultInjection_Delay_ExpDelay); ok {
		return x.ExpDelay
	}
	return nil
}

func (m *HTTPFaultInjection_Delay) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HTTPFaultInjection_Delay) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HTTPFaultInjection_Delay_OneofMarshaler, _HTTPFaultInjection_Delay_OneofUnmarshaler, _HTTPFaultInjection_Delay_OneofSizer, []interface{}{
		(*HTTPFaultInjection_Delay_FixedDelay)(nil),
		(*HTTPFaultInjection_Delay_ExpDelay)(nil),
	}
}

func _HTTPFaultInjection_Delay_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HTTPFaultInjection_Delay)
	// http_delay_type
	switch x := m.HttpDelayType.(type) {
	case *HTTPFaultInjection_Delay_FixedDelay:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FixedDelay); err != nil {
			return err
		}
	case *HTTPFaultInjection_Delay_ExpDelay:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExpDelay); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HTTPFaultInjection_Delay.HttpDelayType has unexpected type %T", x)
	}
	return nil
}

func _HTTPFaultInjection_Delay_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HTTPFaultInjection_Delay)
	switch tag {
	case 1: // http_delay_type.fixed_delay
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HTTPFaultInjection_FixedDelay)
		err := b.DecodeMessage(msg)
		m.HttpDelayType = &HTTPFaultInjection_Delay_FixedDelay{msg}
		return true, err
	case 2: // http_delay_type.exp_delay
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HTTPFaultInjection_ExponentialDelay)
		err := b.DecodeMessage(msg)
		m.HttpDelayType = &HTTPFaultInjection_Delay_ExpDelay{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HTTPFaultInjection_Delay_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HTTPFaultInjection_Delay)
	// http_delay_type
	switch x := m.HttpDelayType.(type) {
	case *HTTPFaultInjection_Delay_FixedDelay:
		s := proto.Size(x.FixedDelay)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HTTPFaultInjection_Delay_ExpDelay:
		s := proto.Size(x.ExpDelay)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Add a fixed delay before forwarding the request
type HTTPFaultInjection_FixedDelay struct {
	// percentage of requests on which the delay will be injected
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// delay duration in seconds.nanoseconds
	FixedDelaySeconds float64 `protobuf:"fixed64,2,opt,name=fixed_delay_seconds,json=fixedDelaySeconds" json:"fixed_delay_seconds,omitempty"`
}

func (m *HTTPFaultInjection_FixedDelay) Reset()         { *m = HTTPFaultInjection_FixedDelay{} }
func (m *HTTPFaultInjection_FixedDelay) String() string { return proto.CompactTextString(m) }
func (*HTTPFaultInjection_FixedDelay) ProtoMessage()    {}
func (*HTTPFaultInjection_FixedDelay) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 2}
}

func (m *HTTPFaultInjection_FixedDelay) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *HTTPFaultInjection_FixedDelay) GetFixedDelaySeconds() float64 {
	if m != nil {
		return m.FixedDelaySeconds
	}
	return 0
}

// Add a delay (based on an exponential function) before forwarding the
// request
type HTTPFaultInjection_ExponentialDelay struct {
	// percentage of requests on which the delay will be injected
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// mean delay needed to derive the exponential delay values
	MeanDelaySeconds float64 `protobuf:"fixed64,2,opt,name=mean_delay_seconds,json=meanDelaySeconds" json:"mean_delay_seconds,omitempty"`
}

func (m *HTTPFaultInjection_ExponentialDelay) Reset()         { *m = HTTPFaultInjection_ExponentialDelay{} }
func (m *HTTPFaultInjection_ExponentialDelay) String() string { return proto.CompactTextString(m) }
func (*HTTPFaultInjection_ExponentialDelay) ProtoMessage()    {}
func (*HTTPFaultInjection_ExponentialDelay) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 3}
}

func (m *HTTPFaultInjection_ExponentialDelay) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *HTTPFaultInjection_ExponentialDelay) GetMeanDelaySeconds() float64 {
	if m != nil {
		return m.MeanDelaySeconds
	}
	return 0
}

// Abort Http request attempts and return error codes back to downstream
// service.
type HTTPFaultInjection_Abort struct {
	// percentage of requests to be aborted with the error code provided.
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// Error code to use to abort the Http request. Requests can be aborted
	// either with Http/1.1 status codes | http2 error codes or gRPC status
	// codes.
	//
	// Types that are valid to be assigned to ErrorType:
	//	*HTTPFaultInjection_Abort_GrpcStatus
	//	*HTTPFaultInjection_Abort_Http2Error
	//	*HTTPFaultInjection_Abort_HttpStatus
	ErrorType isHTTPFaultInjection_Abort_ErrorType `protobuf_oneof:"error_type"`
	// Specify abort code as part of Http request.
	// TODO: The semantics and syntax of the headers is undefined.
	OverrideHeaderName string `protobuf:"bytes,5,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HTTPFaultInjection_Abort) Reset()                    { *m = HTTPFaultInjection_Abort{} }
func (m *HTTPFaultInjection_Abort) String() string            { return proto.CompactTextString(m) }
func (*HTTPFaultInjection_Abort) ProtoMessage()               {}
func (*HTTPFaultInjection_Abort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 4} }

type isHTTPFaultInjection_Abort_ErrorType interface {
	isHTTPFaultInjection_Abort_ErrorType()
}

type HTTPFaultInjection_Abort_GrpcStatus struct {
	GrpcStatus string `protobuf:"bytes,2,opt,name=grpc_status,json=grpcStatus,oneof"`
}
type HTTPFaultInjection_Abort_Http2Error struct {
	Http2Error string `protobuf:"bytes,3,opt,name=http2_error,json=http2Error,oneof"`
}
type HTTPFaultInjection_Abort_HttpStatus struct {
	HttpStatus int32 `protobuf:"varint,4,opt,name=http_status,json=httpStatus,oneof"`
}

func (*HTTPFaultInjection_Abort_GrpcStatus) isHTTPFaultInjection_Abort_ErrorType() {}
func (*HTTPFaultInjection_Abort_Http2Error) isHTTPFaultInjection_Abort_ErrorType() {}
func (*HTTPFaultInjection_Abort_HttpStatus) isHTTPFaultInjection_Abort_ErrorType() {}

func (m *HTTPFaultInjection_Abort) GetErrorType() isHTTPFaultInjection_Abort_ErrorType {
	if m != nil {
		return m.ErrorType
	}
	return nil
}

func (m *HTTPFaultInjection_Abort) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *HTTPFaultInjection_Abort) GetGrpcStatus() string {
	if x, ok := m.GetErrorType().(*HTTPFaultInjection_Abort_GrpcStatus); ok {
		return x.GrpcStatus
	}
	return ""
}

func (m *HTTPFaultInjection_Abort) GetHttp2Error() string {
	if x, ok := m.GetErrorType().(*HTTPFaultInjection_Abort_Http2Error); ok {
		return x.Http2Error
	}
	return ""
}

func (m *HTTPFaultInjection_Abort) GetHttpStatus() int32 {
	if x, ok := m.GetErrorType().(*HTTPFaultInjection_Abort_HttpStatus); ok {
		return x.HttpStatus
	}
	return 0
}

func (m *HTTPFaultInjection_Abort) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HTTPFaultInjection_Abort) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HTTPFaultInjection_Abort_OneofMarshaler, _HTTPFaultInjection_Abort_OneofUnmarshaler, _HTTPFaultInjection_Abort_OneofSizer, []interface{}{
		(*HTTPFaultInjection_Abort_GrpcStatus)(nil),
		(*HTTPFaultInjection_Abort_Http2Error)(nil),
		(*HTTPFaultInjection_Abort_HttpStatus)(nil),
	}
}

func _HTTPFaultInjection_Abort_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HTTPFaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *HTTPFaultInjection_Abort_GrpcStatus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.GrpcStatus)
	case *HTTPFaultInjection_Abort_Http2Error:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Http2Error)
	case *HTTPFaultInjection_Abort_HttpStatus:
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		return fmt.Errorf("HTTPFaultInjection_Abort.ErrorType has unexpected type %T", x)
	}
	return nil
}

func _HTTPFaultInjection_Abort_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HTTPFaultInjection_Abort)
	switch tag {
	case 2: // error_type.grpc_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ErrorType = &HTTPFaultInjection_Abort_GrpcStatus{x}
		return true, err
	case 3: // error_type.http2_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ErrorType = &HTTPFaultInjection_Abort_Http2Error{x}
		return true, err
	case 4: // error_type.http_status
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ErrorType = &HTTPFaultInjection_Abort_HttpStatus{int32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _HTTPFaultInjection_Abort_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HTTPFaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *HTTPFaultInjection_Abort_GrpcStatus:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.GrpcStatus)))
		n += len(x.GrpcStatus)
	case *HTTPFaultInjection_Abort_Http2Error:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Http2Error)))
		n += len(x.Http2Error)
	case *HTTPFaultInjection_Abort_HttpStatus:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Faults can be injected into the connections from downstream by the
// proxy, for testing the failure recovery capabilities of downstream
// services.  Faults include aborting the request/connection from
// downstream service, delaying the proxying of request/connection to the
// upstream service, and throttling the bandwidth of the connection
// (either end).
type L4FaultInjection struct {
	// We first throttle (if set) and then terminate the connection.
	Throttle  *L4FaultInjection_Throttle  `protobuf:"bytes,1,opt,name=throttle" json:"throttle,omitempty"`
	Terminate *L4FaultInjection_Terminate `protobuf:"bytes,2,opt,name=terminate" json:"terminate,omitempty"`
}

func (m *L4FaultInjection) Reset()                    { *m = L4FaultInjection{} }
func (m *L4FaultInjection) String() string            { return proto.CompactTextString(m) }
func (*L4FaultInjection) ProtoMessage()               {}
func (*L4FaultInjection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *L4FaultInjection) GetThrottle() *L4FaultInjection_Throttle {
	if m != nil {
		return m.Throttle
	}
	return nil
}

func (m *L4FaultInjection) GetTerminate() *L4FaultInjection_Terminate {
	if m != nil {
		return m.Terminate
	}
	return nil
}

// Bandwidth throttling for Tcp and Udp connections
type L4FaultInjection_Throttle struct {
	// percentage of connections to throttle.
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// bandwidth limit in "bits" per second between downstream and proxy
	DownstreamLimitBps int64 `protobuf:"varint,2,opt,name=downstream_limit_bps,json=downstreamLimitBps" json:"downstream_limit_bps,omitempty"`
	// bandwidth limits in "bits" per second between proxy and upstream
	UpstreamLimitBps int64 `protobuf:"varint,3,opt,name=upstream_limit_bps,json=upstreamLimitBps" json:"upstream_limit_bps,omitempty"`
	// Types that are valid to be assigned to ThrottleAfter:
	//	*L4FaultInjection_Throttle_ThrottleAfterSeconds
	//	*L4FaultInjection_Throttle_ThrottleAfterBytes
	ThrottleAfter isL4FaultInjection_Throttle_ThrottleAfter `protobuf_oneof:"throttle_after"`
	// Stop throttling after the given duration. If not set, the connection
	// will be throttled for its lifetime.
	ThrottleForSeconds *google_protobuf1.DoubleValue `protobuf:"bytes,6,opt,name=throttle_for_seconds,json=throttleForSeconds" json:"throttle_for_seconds,omitempty"`
}

func (m *L4FaultInjection_Throttle) Reset()                    { *m = L4FaultInjection_Throttle{} }
func (m *L4FaultInjection_Throttle) String() string            { return proto.CompactTextString(m) }
func (*L4FaultInjection_Throttle) ProtoMessage()               {}
func (*L4FaultInjection_Throttle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

type isL4FaultInjection_Throttle_ThrottleAfter interface {
	isL4FaultInjection_Throttle_ThrottleAfter()
}

type L4FaultInjection_Throttle_ThrottleAfterSeconds struct {
	ThrottleAfterSeconds float64 `protobuf:"fixed64,4,opt,name=throttle_after_seconds,json=throttleAfterSeconds,oneof"`
}
type L4FaultInjection_Throttle_ThrottleAfterBytes struct {
	ThrottleAfterBytes float64 `protobuf:"fixed64,5,opt,name=throttle_after_bytes,json=throttleAfterBytes,oneof"`
}

func (*L4FaultInjection_Throttle_ThrottleAfterSeconds) isL4FaultInjection_Throttle_ThrottleAfter() {}
func (*L4FaultInjection_Throttle_ThrottleAfterBytes) isL4FaultInjection_Throttle_ThrottleAfter()   {}

func (m *L4FaultInjection_Throttle) GetThrottleAfter() isL4FaultInjection_Throttle_ThrottleAfter {
	if m != nil {
		return m.ThrottleAfter
	}
	return nil
}

func (m *L4FaultInjection_Throttle) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetDownstreamLimitBps() int64 {
	if m != nil {
		return m.DownstreamLimitBps
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetUpstreamLimitBps() int64 {
	if m != nil {
		return m.UpstreamLimitBps
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetThrottleAfterSeconds() float64 {
	if x, ok := m.GetThrottleAfter().(*L4FaultInjection_Throttle_ThrottleAfterSeconds); ok {
		return x.ThrottleAfterSeconds
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetThrottleAfterBytes() float64 {
	if x, ok := m.GetThrottleAfter().(*L4FaultInjection_Throttle_ThrottleAfterBytes); ok {
		return x.ThrottleAfterBytes
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetThrottleForSeconds() *google_protobuf1.DoubleValue {
	if m != nil {
		return m.ThrottleForSeconds
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*L4FaultInjection_Throttle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _L4FaultInjection_Throttle_OneofMarshaler, _L4FaultInjection_Throttle_OneofUnmarshaler, _L4FaultInjection_Throttle_OneofSizer, []interface{}{
		(*L4FaultInjection_Throttle_ThrottleAfterSeconds)(nil),
		(*L4FaultInjection_Throttle_ThrottleAfterBytes)(nil),
	}
}

func _L4FaultInjection_Throttle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*L4FaultInjection_Throttle)
	// throttle_after
	switch x := m.ThrottleAfter.(type) {
	case *L4FaultInjection_Throttle_ThrottleAfterSeconds:
		b.EncodeVarint(4<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.ThrottleAfterSeconds))
	case *L4FaultInjection_Throttle_ThrottleAfterBytes:
		b.EncodeVarint(5<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.ThrottleAfterBytes))
	case nil:
	default:
		return fmt.Errorf("L4FaultInjection_Throttle.ThrottleAfter has unexpected type %T", x)
	}
	return nil
}

func _L4FaultInjection_Throttle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*L4FaultInjection_Throttle)
	switch tag {
	case 4: // throttle_after.throttle_after_seconds
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ThrottleAfter = &L4FaultInjection_Throttle_ThrottleAfterSeconds{math.Float64frombits(x)}
		return true, err
	case 5: // throttle_after.throttle_after_bytes
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ThrottleAfter = &L4FaultInjection_Throttle_ThrottleAfterBytes{math.Float64frombits(x)}
		return true, err
	default:
		return false, nil
	}
}

func _L4FaultInjection_Throttle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*L4FaultInjection_Throttle)
	// throttle_after
	switch x := m.ThrottleAfter.(type) {
	case *L4FaultInjection_Throttle_ThrottleAfterSeconds:
		n += proto.SizeVarint(4<<3 | proto.WireFixed64)
		n += 8
	case *L4FaultInjection_Throttle_ThrottleAfterBytes:
		n += proto.SizeVarint(5<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Abruptly reset (terminate) the Tcp connection after it has been
// established, emulating remote server crash or link failure.
type L4FaultInjection_Terminate struct {
	// percentage of established Tcp connections to be terminated/reset
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// TODO: see if it makes sense to create a generic Duration type to
	// express time interval related configs.
	TerminateAfterSeconds float64 `protobuf:"fixed64,2,opt,name=terminate_after_seconds,json=terminateAfterSeconds" json:"terminate_after_seconds,omitempty"`
}

func (m *L4FaultInjection_Terminate) Reset()                    { *m = L4FaultInjection_Terminate{} }
func (m *L4FaultInjection_Terminate) String() string            { return proto.CompactTextString(m) }
func (*L4FaultInjection_Terminate) ProtoMessage()               {}
func (*L4FaultInjection_Terminate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 1} }

func (m *L4FaultInjection_Terminate) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *L4FaultInjection_Terminate) GetTerminateAfterSeconds() float64 {
	if m != nil {
		return m.TerminateAfterSeconds
	}
	return 0
}

func init() {
	proto.RegisterType((*ProxyMeshConfig)(nil), "istio.proxy.v1alpha.config.ProxyMeshConfig")
	proto.RegisterType((*Destination)(nil), "istio.proxy.v1alpha.config.Destination")
	proto.RegisterType((*RouteRule)(nil), "istio.proxy.v1alpha.config.RouteRule")
	proto.RegisterType((*MatchCondition)(nil), "istio.proxy.v1alpha.config.MatchCondition")
	proto.RegisterType((*DestinationWeight)(nil), "istio.proxy.v1alpha.config.DestinationWeight")
	proto.RegisterType((*L4MatchAttributes)(nil), "istio.proxy.v1alpha.config.L4MatchAttributes")
	proto.RegisterType((*StringMatch)(nil), "istio.proxy.v1alpha.config.StringMatch")
	proto.RegisterType((*LoadBalancing)(nil), "istio.proxy.v1alpha.config.LoadBalancing")
	proto.RegisterType((*HTTPTimeout)(nil), "istio.proxy.v1alpha.config.HTTPTimeout")
	proto.RegisterType((*HTTPTimeout_SimpleTimeoutPolicy)(nil), "istio.proxy.v1alpha.config.HTTPTimeout.SimpleTimeoutPolicy")
	proto.RegisterType((*HTTPRetry)(nil), "istio.proxy.v1alpha.config.HTTPRetry")
	proto.RegisterType((*HTTPRetry_SimpleRetryPolicy)(nil), "istio.proxy.v1alpha.config.HTTPRetry.SimpleRetryPolicy")
	proto.RegisterType((*CircuitBreaker)(nil), "istio.proxy.v1alpha.config.CircuitBreaker")
	proto.RegisterType((*CircuitBreaker_SimpleCircuitBreakerPolicy)(nil), "istio.proxy.v1alpha.config.CircuitBreaker.SimpleCircuitBreakerPolicy")
	proto.RegisterType((*HTTPFaultInjection)(nil), "istio.proxy.v1alpha.config.HTTPFaultInjection")
	proto.RegisterType((*HTTPFaultInjection_Delay)(nil), "istio.proxy.v1alpha.config.HTTPFaultInjection.Delay")
	proto.RegisterType((*HTTPFaultInjection_FixedDelay)(nil), "istio.proxy.v1alpha.config.HTTPFaultInjection.FixedDelay")
	proto.RegisterType((*HTTPFaultInjection_ExponentialDelay)(nil), "istio.proxy.v1alpha.config.HTTPFaultInjection.ExponentialDelay")
	proto.RegisterType((*HTTPFaultInjection_Abort)(nil), "istio.proxy.v1alpha.config.HTTPFaultInjection.Abort")
	proto.RegisterType((*L4FaultInjection)(nil), "istio.proxy.v1alpha.config.L4FaultInjection")
	proto.RegisterType((*L4FaultInjection_Throttle)(nil), "istio.proxy.v1alpha.config.L4FaultInjection.Throttle")
	proto.RegisterType((*L4FaultInjection_Terminate)(nil), "istio.proxy.v1alpha.config.L4FaultInjection.Terminate")
	proto.RegisterEnum("istio.proxy.v1alpha.config.LoadBalancing_SimpleLBPolicy", LoadBalancing_SimpleLBPolicy_name, LoadBalancing_SimpleLBPolicy_value)
}

func init() { proto.RegisterFile("cfg.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1731 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x72, 0x1b, 0xc7,
	0x11, 0x26, 0x00, 0x2e, 0x48, 0x34, 0x28, 0x10, 0x18, 0x51, 0x34, 0x8c, 0x72, 0xb9, 0x68, 0xa6,
	0x52, 0x52, 0x1c, 0x09, 0xb6, 0x19, 0x45, 0xf2, 0x4f, 0xa9, 0x1c, 0x82, 0xa4, 0x02, 0x39, 0x22,
	0xc5, 0x0c, 0x61, 0xbb, 0xca, 0x71, 0xb2, 0x19, 0xec, 0x36, 0x80, 0x8d, 0x17, 0xbb, 0x9b, 0xd9,
	0x59, 0x12, 0x78, 0x85, 0x54, 0xae, 0x79, 0x86, 0xdc, 0xf2, 0x20, 0xc9, 0x2d, 0xc9, 0x2d, 0x0f,
	0x91, 0xaa, 0x1c, 0x72, 0x4e, 0xcd, 0xcf, 0x2e, 0x16, 0xa0, 0x08, 0x11, 0xae, 0xca, 0x0d, 0xfd,
	0xf3, 0x7d, 0xdb, 0xdd, 0xd3, 0xd3, 0xd3, 0x24, 0x54, 0x9c, 0xc1, 0xb0, 0x1d, 0xf1, 0x50, 0x84,
	0xa4, 0xe5, 0xc5, 0xc2, 0x0b, 0xa5, 0x30, 0x99, 0xb6, 0x2f, 0x3f, 0x62, 0x7e, 0x34, 0x62, 0x6d,
	0x27, 0x0c, 0x06, 0xde, 0xb0, 0xf5, 0xf6, 0x30, 0x0c, 0x87, 0x3e, 0x7e, 0xa0, 0x3c, 0xfb, 0xc9,
	0xe0, 0x03, 0x16, 0x4c, 0x35, 0xac, 0xf5, 0xee, 0xa2, 0xe9, 0x8a, 0xb3, 0x28, 0x42, 0x1e, 0x6b,
	0xfb, 0x7e, 0x03, 0xb6, 0xcf, 0x25, 0xe5, 0x29, 0xc6, 0xa3, 0x23, 0xc5, 0xb6, 0xff, 0x17, 0x0b,
	0xaa, 0xc7, 0x18, 0x0b, 0x2f, 0x60, 0xc2, 0x0b, 0x03, 0xb2, 0x07, 0x55, 0x77, 0x26, 0x36, 0x0b,
	0x7b, 0x85, 0x07, 0x15, 0x9a, 0x57, 0x91, 0x13, 0x58, 0x17, 0x6c, 0x18, 0x37, 0x8b, 0x7b, 0xa5,
	0x07, 0xd5, 0x83, 0x8f, 0xda, 0x37, 0x87, 0xda, 0xce, 0x11, 0xb7, 0x7b, 0x6c, 0x18, 0x9f, 0x04,
	0x82, 0x4f, 0xa9, 0x82, 0x93, 0x73, 0xa8, 0xf9, 0x21, 0x73, 0xed, 0x3e, 0xf3, 0x59, 0xe0, 0x78,
	0xc1, 0xb0, 0x59, 0xda, 0x2b, 0x3c, 0xa8, 0x1e, 0xfc, 0x68, 0x19, 0xe1, 0xcb, 0x90, 0xb9, 0x9d,
	0x14, 0x40, 0xef, 0xf8, 0x79, 0x91, 0x5c, 0xc0, 0xb6, 0xe3, 0x71, 0x27, 0xf1, 0x84, 0xdd, 0xe7,
	0xc8, 0xbe, 0x43, 0xde, 0x5c, 0x57, 0x94, 0xef, 0x2f, 0xa3, 0x3c, 0xd2, 0x90, 0x8e, 0x46, 0xd0,
	0x9a, 0x33, 0x27, 0x93, 0x2f, 0x60, 0x6b, 0x24, 0x44, 0x64, 0x0b, 0x6f, 0x8c, 0x61, 0x22, 0x9a,
	0x96, 0x62, 0xbc, 0xbf, 0x8c, 0xb1, 0xdb, 0xeb, 0x9d, 0xf7, 0xb4, 0x3b, 0xad, 0x4a, 0xb0, 0x11,
	0xc8, 0x31, 0x80, 0xe2, 0xe2, 0x28, 0xf8, 0xb4, 0x59, 0x56, 0x4c, 0x3f, 0x7c, 0x13, 0x13, 0x95,
	0xce, 0xb4, 0x22, 0x81, 0xea, 0x27, 0x39, 0x35, 0x2c, 0x03, 0x96, 0xf8, 0xa2, 0xb9, 0xa1, 0x58,
	0xda, 0x6f, 0x62, 0x79, 0x2e, 0x9d, 0x5f, 0x04, 0xbf, 0x43, 0x47, 0x1e, 0x86, 0xa6, 0x53, 0x3a,
	0xf2, 0x73, 0xd8, 0xf4, 0x1f, 0x1b, 0xb2, 0x4d, 0x45, 0xf6, 0x70, 0xe9, 0x09, 0x3c, 0x5e, 0xa0,
	0xda, 0xf0, 0xb5, 0x86, 0x3c, 0x84, 0xb2, 0x93, 0xc4, 0x22, 0x1c, 0x37, 0x2b, 0x8a, 0x66, 0xa7,
	0xad, 0xbb, 0xb1, 0x9d, 0x76, 0x63, 0xfb, 0x30, 0x98, 0x52, 0xe3, 0xd3, 0x7a, 0x0a, 0x95, 0xac,
	0x23, 0x48, 0x1d, 0x4a, 0xdf, 0xe1, 0xd4, 0x34, 0x9b, 0xfc, 0x49, 0x76, 0xc0, 0xba, 0x64, 0x7e,
	0x82, 0xcd, 0xa2, 0xd2, 0x69, 0xe1, 0xd3, 0xe2, 0xc7, 0x85, 0xfd, 0x7f, 0x16, 0xa0, 0x42, 0xc3,
	0x44, 0x20, 0x4d, 0x7c, 0xbc, 0x45, 0xbb, 0xfe, 0x0c, 0xac, 0x31, 0x13, 0xce, 0x48, 0x31, 0xbd,
	0xa1, 0x17, 0x4e, 0xa5, 0xe3, 0x51, 0x18, 0xb8, 0x9e, 0x4a, 0x4d, 0x03, 0xc9, 0x11, 0x58, 0x5c,
	0x7e, 0xb0, 0x59, 0x52, 0x1d, 0xff, 0xe8, 0x96, 0x1d, 0xff, 0x35, 0x7a, 0xc3, 0x91, 0xa0, 0x1a,
	0x4b, 0xde, 0x05, 0x88, 0x38, 0x3a, 0xe8, 0x62, 0xe0, 0xa0, 0xea, 0x4b, 0x8b, 0xe6, 0x34, 0xfb,
	0xff, 0x29, 0x41, 0x6d, 0xfe, 0xf3, 0x64, 0x17, 0xca, 0x71, 0x98, 0x70, 0x07, 0x4d, 0x5a, 0x46,
	0x22, 0xbf, 0x82, 0xaa, 0xfe, 0x65, 0xe7, 0xee, 0xe1, 0xa7, 0xb7, 0xcf, 0xab, 0x7d, 0xa1, 0xd0,
	0xb3, 0x0b, 0x09, 0x71, 0xa6, 0x20, 0x9f, 0x43, 0x49, 0x38, 0x91, 0xb9, 0x8b, 0x8f, 0x96, 0x77,
	0x82, 0xa2, 0x3d, 0x14, 0x82, 0x7b, 0xfd, 0x44, 0x60, 0x4c, 0x25, 0x52, 0x12, 0x24, 0x6e, 0x64,
	0x6e, 0xde, 0xaa, 0x04, 0x89, 0x1b, 0x91, 0x2e, 0xac, 0xcb, 0xee, 0x6c, 0x5a, 0x2a, 0xaf, 0xc7,
	0x2b, 0xe4, 0xd5, 0x15, 0x22, 0x32, 0x23, 0x46, 0x32, 0xb4, 0x9e, 0xc1, 0xf6, 0x42, 0xaa, 0xab,
	0x74, 0x5a, 0xeb, 0xb7, 0x50, 0xc9, 0x18, 0x5f, 0x03, 0x7c, 0x96, 0x07, 0xbe, 0x61, 0x24, 0x5c,
	0x08, 0xee, 0x05, 0x43, 0x15, 0x6e, 0xbe, 0x97, 0xff, 0x51, 0x80, 0xc6, 0xb5, 0x8e, 0xb9, 0x45,
	0x4f, 0xff, 0x62, 0x6e, 0x04, 0x3f, 0x5d, 0xa9, 0x21, 0xaf, 0x0d, 0xe2, 0x5d, 0x28, 0x5f, 0x29,
	0x8b, 0x3a, 0x74, 0x8b, 0x1a, 0xe9, 0xfb, 0xdf, 0xd0, 0x21, 0x34, 0xae, 0x1d, 0x2d, 0xf9, 0x01,
	0xdc, 0x31, 0x4d, 0x1b, 0x27, 0xfd, 0x00, 0x45, 0xb3, 0xb0, 0x57, 0x7a, 0x50, 0xa1, 0x5b, 0x5a,
	0x79, 0xa1, 0x74, 0xe4, 0x11, 0x90, 0x5c, 0x9a, 0xa9, 0x67, 0x51, 0x79, 0x36, 0x72, 0x16, 0xed,
	0xbe, 0x8f, 0x50, 0xcd, 0x15, 0x96, 0xec, 0x82, 0x85, 0x13, 0xe6, 0x08, 0x1d, 0x65, 0x77, 0x8d,
	0x6a, 0x91, 0x34, 0xa1, 0x1c, 0x71, 0x1c, 0x78, 0x13, 0x1d, 0x6a, 0x77, 0x8d, 0x1a, 0x59, 0x22,
	0x38, 0x0e, 0x71, 0xa2, 0x32, 0x57, 0x08, 0x25, 0x76, 0xb6, 0x00, 0xd4, 0xd5, 0xb7, 0xc5, 0x34,
	0xc2, 0xfd, 0x7f, 0x15, 0xe0, 0xce, 0xdc, 0xc3, 0x43, 0xce, 0x60, 0x3d, 0x60, 0x63, 0x7d, 0x2f,
	0x6b, 0x07, 0x1f, 0xdf, 0xfa, 0xc5, 0x6a, 0x5f, 0x78, 0xe3, 0xc8, 0xc7, 0x97, 0x9d, 0xf3, 0xd0,
	0xf7, 0x9c, 0x69, 0x77, 0x8d, 0x2a, 0x1e, 0xd2, 0xce, 0x46, 0x67, 0xf1, 0xe6, 0xd1, 0x29, 0xe3,
	0xd6, 0x5e, 0xfb, 0xcf, 0xa0, 0x36, 0xcf, 0x44, 0xb6, 0xa1, 0x4a, 0x5f, 0x7d, 0x79, 0x76, 0x6c,
	0xd3, 0x57, 0x9d, 0x17, 0x67, 0xf5, 0x35, 0x52, 0x03, 0x78, 0x79, 0x72, 0x78, 0xd1, 0xb3, 0x8f,
	0x5e, 0x9d, 0x9d, 0xd5, 0x0b, 0x04, 0xa0, 0x4c, 0x0f, 0xcf, 0x8e, 0x5f, 0x9d, 0xd6, 0x4b, 0x9d,
	0x2a, 0x54, 0xfc, 0xbe, 0x1d, 0x29, 0xe4, 0xfe, 0x9f, 0x8b, 0x50, 0xcd, 0xbd, 0x58, 0xc4, 0x85,
	0x5a, 0xac, 0xb8, 0xb3, 0x27, 0xaf, 0xa0, 0x62, 0xfa, 0xec, 0x96, 0x4f, 0x9e, 0xc9, 0xd1, 0x48,
	0x59, 0xa2, 0x77, 0xe2, 0xbc, 0x7a, 0xd5, 0x8c, 0x5b, 0x11, 0xdc, 0x7d, 0x0d, 0x2f, 0xb9, 0x0f,
	0xdb, 0x26, 0x4a, 0x3b, 0x46, 0x27, 0x0c, 0xdc, 0x58, 0x45, 0x5b, 0xa0, 0x35, 0xa3, 0xbe, 0xd0,
	0x5a, 0xf2, 0x21, 0xec, 0x84, 0x97, 0xc8, 0xb9, 0xe7, 0xa2, 0x3d, 0x42, 0xe6, 0x22, 0xb7, 0xd5,
	0x09, 0xea, 0xe6, 0x25, 0xa9, 0xad, 0xab, 0x4c, 0x67, 0x6c, 0x8c, 0x9d, 0x3a, 0xa4, 0x1c, 0x69,
	0xa5, 0xfe, 0x58, 0x84, 0x4a, 0xf6, 0x22, 0x93, 0x6f, 0x61, 0xcb, 0xd4, 0x49, 0x3f, 0xe7, 0xba,
	0x4a, 0x4f, 0x6f, 0xf5, 0x9c, 0x9b, 0x1a, 0xa9, 0xdf, 0x59, 0x85, 0xaa, 0xf1, 0x4c, 0xb9, 0x72,
	0x7d, 0x18, 0x34, 0xae, 0x71, 0x92, 0x16, 0x6c, 0x32, 0x21, 0x70, 0x1c, 0x09, 0x5d, 0x16, 0x8b,
	0x66, 0xf2, 0xf7, 0x28, 0x48, 0x0d, 0xb6, 0x54, 0xa6, 0x69, 0x39, 0xfe, 0x66, 0x41, 0x6d, 0x7e,
	0x79, 0x22, 0x2e, 0x54, 0x4c, 0x4d, 0x9c, 0xbe, 0x29, 0xc8, 0xc9, 0xed, 0x77, 0x2f, 0x53, 0x95,
	0x79, 0x65, 0x56, 0x9e, 0x4d, 0xcd, 0x7c, 0xd4, 0x5f, 0xb9, 0x36, 0x7f, 0x5a, 0x87, 0xd6, 0xcd,
	0xd4, 0xe4, 0xc7, 0xd0, 0x88, 0x13, 0xc7, 0xc1, 0x38, 0xb6, 0xc5, 0x88, 0x63, 0x3c, 0x0a, 0x7d,
	0xd7, 0x94, 0xab, 0x6e, 0x0c, 0xbd, 0x54, 0x2f, 0x9d, 0x07, 0xcc, 0xf3, 0x13, 0x8e, 0x39, 0xe7,
	0xa2, 0x76, 0x36, 0x86, 0x99, 0xf3, 0x01, 0xdc, 0xe3, 0x18, 0xa3, 0xb0, 0x17, 0x7b, 0xb4, 0xa4,
	0x7a, 0xf4, 0xae, 0x32, 0xf6, 0xe6, 0x1b, 0xf5, 0x3e, 0x6c, 0x8f, 0xd9, 0xc4, 0x76, 0xc2, 0x20,
	0xd0, 0x0b, 0x56, 0x6c, 0x96, 0x85, 0xda, 0x98, 0x4d, 0x8e, 0x66, 0x5a, 0xf2, 0x09, 0xbc, 0xad,
	0xd6, 0x40, 0xe9, 0x1d, 0x61, 0xe0, 0x7a, 0xc1, 0xd0, 0xe6, 0xf8, 0xfb, 0x04, 0x63, 0x11, 0xab,
	0x2d, 0xd5, 0xa2, 0xbb, 0xd2, 0xe1, 0x94, 0x4d, 0xce, 0xb5, 0x99, 0x1a, 0x2b, 0x79, 0x1f, 0x1a,
	0x19, 0x34, 0x83, 0x94, 0x15, 0x64, 0xdb, 0x40, 0x32, 0xdf, 0xf7, 0x60, 0x2b, 0xf6, 0x11, 0x23,
	0xfb, 0xca, 0x0b, 0xdc, 0xf0, 0x4a, 0xed, 0x9b, 0x15, 0x5a, 0x55, 0xba, 0xaf, 0x95, 0x8a, 0x3c,
	0x81, 0xb7, 0x14, 0x9d, 0x13, 0x06, 0x31, 0x3a, 0x89, 0xf0, 0x2e, 0xd1, 0x46, 0xce, 0x43, 0x1e,
	0xab, 0x85, 0xd2, 0xa2, 0xf7, 0xa4, 0xf9, 0x68, 0x66, 0x3d, 0x51, 0xc6, 0x0c, 0xe7, 0xa2, 0xd0,
	0x49, 0xd9, 0x5e, 0x20, 0x90, 0x5f, 0x32, 0x5f, 0x6d, 0x90, 0x06, 0x77, 0x9c, 0x5a, 0x5f, 0x18,
	0x23, 0x79, 0x0e, 0x7b, 0xd7, 0xc2, 0xb7, 0x23, 0xe4, 0xb9, 0xa2, 0x35, 0x41, 0x11, 0xbc, 0xb3,
	0x90, 0xcd, 0x39, 0xf2, 0x59, 0x09, 0xe5, 0x18, 0x74, 0xb2, 0x31, 0xf8, 0xdf, 0x0d, 0x20, 0xd7,
	0x17, 0x65, 0xf2, 0x05, 0x58, 0x2e, 0xfa, 0x2c, 0xbd, 0xde, 0x8f, 0x57, 0xdb, 0xb3, 0xdb, 0xc7,
	0x12, 0x4b, 0x35, 0x85, 0xe4, 0x62, 0xfd, 0x90, 0x0b, 0xd3, 0xb6, 0xab, 0x72, 0x1d, 0x4a, 0x2c,
	0xd5, 0x14, 0xe4, 0x4b, 0xd8, 0xd0, 0xb7, 0x36, 0x36, 0x5b, 0xe9, 0x67, 0x2b, 0xb2, 0xe9, 0x8b,
	0x6d, 0x16, 0x81, 0x94, 0xab, 0xe5, 0xc0, 0x56, 0xde, 0xf0, 0x7f, 0xd9, 0x7a, 0x5a, 0x7f, 0x28,
	0x82, 0xa5, 0x0a, 0x43, 0xbe, 0x85, 0xea, 0xc0, 0x9b, 0xa0, 0x6b, 0xe7, 0x6b, 0xfc, 0xc9, 0x8a,
	0x99, 0x3c, 0x97, 0x0c, 0x8a, 0xaf, 0xbb, 0x46, 0x61, 0x90, 0x49, 0xe4, 0x37, 0x50, 0xc1, 0x49,
	0x64, 0xb8, 0x75, 0xb8, 0x9f, 0xaf, 0xc8, 0x7d, 0x32, 0x89, 0xc2, 0x00, 0x03, 0xe1, 0x31, 0x3f,
	0xfd, 0xc2, 0x26, 0x4e, 0x22, 0xcd, 0x7f, 0xd3, 0x08, 0x2d, 0xdd, 0x38, 0x42, 0x1b, 0xb0, 0x6d,
	0x3a, 0xde, 0x67, 0x53, 0xb5, 0x5c, 0xb4, 0xbe, 0x02, 0x98, 0x25, 0x40, 0x9a, 0xb0, 0x11, 0x21,
	0x77, 0x30, 0xd0, 0xaf, 0x6e, 0x91, 0xa6, 0x22, 0x69, 0xc3, 0xdd, 0x5c, 0xa9, 0xb2, 0x49, 0x52,
	0x54, 0x93, 0xa4, 0x31, 0xcb, 0xda, 0xcc, 0x91, 0xd6, 0x37, 0x50, 0x5f, 0x0c, 0x7e, 0x09, 0xfb,
	0x43, 0x20, 0x63, 0x64, 0xc1, 0x6b, 0xc9, 0xeb, 0xd2, 0x32, 0xc7, 0xfd, 0xd7, 0x02, 0x58, 0xaa,
	0x1b, 0x97, 0x30, 0xbe, 0x07, 0xd5, 0x21, 0x8f, 0x1c, 0x3b, 0x16, 0x4c, 0x24, 0x71, 0xb6, 0x79,
	0x81, 0x54, 0x5e, 0x28, 0x9d, 0x74, 0x91, 0xd5, 0x38, 0xd0, 0xc3, 0x22, 0xdb, 0xc1, 0xd4, 0x5f,
	0xb7, 0x07, 0x6a, 0x46, 0xa4, 0x2e, 0x29, 0x8b, 0x9a, 0x84, 0xa9, 0x8b, 0x61, 0xb9, 0xe9, 0x14,
	0xac, 0x1b, 0x4f, 0x61, 0x0b, 0x40, 0x7d, 0x51, 0x6f, 0x77, 0xff, 0x5e, 0x87, 0xfa, 0xe2, 0x1f,
	0xb5, 0xe4, 0x97, 0xb0, 0x29, 0x46, 0x3c, 0x14, 0xc2, 0x47, 0xd3, 0x95, 0x3f, 0x5d, 0xe5, 0x8f,
	0xe2, 0x76, 0xcf, 0x80, 0x69, 0x46, 0x43, 0x7a, 0x50, 0x11, 0xc8, 0xc7, 0x72, 0x83, 0x4d, 0x2f,
	0xcf, 0x93, 0xd5, 0x38, 0x53, 0x34, 0x9d, 0x11, 0xb5, 0xfe, 0x5e, 0x84, 0xcd, 0xf4, 0x63, 0x4b,
	0x4e, 0xe3, 0x43, 0xd8, 0x71, 0xc3, 0xab, 0x20, 0x16, 0x1c, 0xd9, 0xd8, 0xf6, 0xbd, 0xb1, 0x27,
	0xec, 0x7e, 0xa4, 0x8f, 0xa5, 0x44, 0xc9, 0xcc, 0xf6, 0x52, 0x9a, 0x3a, 0x51, 0x2c, 0x3b, 0x22,
	0x89, 0xae, 0xf9, 0x97, 0x94, 0x7f, 0x3d, 0xb5, 0x64, 0xde, 0x4f, 0x60, 0x37, 0x4d, 0xd4, 0x66,
	0x03, 0x81, 0x3c, 0xeb, 0x21, 0x79, 0x64, 0x85, 0xee, 0x1a, 0xdd, 0x49, 0xed, 0x87, 0xd2, 0x9c,
	0xbe, 0x76, 0x07, 0xb0, 0xb3, 0x80, 0xeb, 0x4f, 0x05, 0xea, 0xf7, 0x4b, 0xa2, 0xc8, 0x1c, 0xaa,
	0x23, 0x6d, 0xe4, 0x2c, 0x87, 0x19, 0x84, 0xb3, 0x2f, 0xe9, 0xff, 0xa7, 0xbc, 0x73, 0x6d, 0x19,
	0x38, 0x0e, 0x93, 0xbe, 0x8f, 0x5f, 0xc9, 0xf1, 0x33, 0xe3, 0x7b, 0x1e, 0xa6, 0x31, 0xa8, 0x45,
	0x6f, 0x2e, 0x86, 0xd6, 0xaf, 0xa1, 0x92, 0x15, 0x7b, 0x49, 0x51, 0x9f, 0xc0, 0x5b, 0xd9, 0x41,
	0x2c, 0x64, 0xad, 0x6f, 0xce, 0xbd, 0xcc, 0x9c, 0x4f, 0xba, 0xb3, 0xf9, 0x4d, 0x59, 0x9f, 0x71,
	0xbf, 0xac, 0x82, 0xfc, 0xc9, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x18, 0x4b, 0x77, 0xea, 0xfa,
	0x13, 0x00, 0x00,
}
