// Code generated by protoc-gen-go.
// source: cfg.proto
// DO NOT EDIT!

/*
Package config is a generated protocol buffer package.

It is generated from these files:
	cfg.proto

It has these top-level messages:
	ProxyMeshConfig
	DestinationPolicy
	RouteRule
	MatchCondition
	DestinationWeight
	L4MatchAttributes
	StringMatch
	LoadBalancing
	HTTPTimeout
	HTTPRetry
	CircuitBreaker
	HTTPFaultInjection
	L4FaultInjection
*/
package config

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"
import google_protobuf1 "github.com/golang/protobuf/ptypes/wrappers"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// / Common load balancing policies supported in Istio service mesh.
type LoadBalancing_SimpleLBPolicy int32

const (
	LoadBalancing_ROUND_ROBIN LoadBalancing_SimpleLBPolicy = 0
	LoadBalancing_LEAST_CONN  LoadBalancing_SimpleLBPolicy = 1
	LoadBalancing_RANDOM      LoadBalancing_SimpleLBPolicy = 2
)

var LoadBalancing_SimpleLBPolicy_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_CONN",
	2: "RANDOM",
}
var LoadBalancing_SimpleLBPolicy_value = map[string]int32{
	"ROUND_ROBIN": 0,
	"LEAST_CONN":  1,
	"RANDOM":      2,
}

func (x LoadBalancing_SimpleLBPolicy) String() string {
	return proto.EnumName(LoadBalancing_SimpleLBPolicy_name, int32(x))
}
func (LoadBalancing_SimpleLBPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 0}
}

// /@exclude Proxy level global configurations go here
type ProxyMeshConfig struct {
}

func (m *ProxyMeshConfig) Reset()                    { *m = ProxyMeshConfig{} }
func (m *ProxyMeshConfig) String() string            { return proto.CompactTextString(m) }
func (*ProxyMeshConfig) ProtoMessage()               {}
func (*ProxyMeshConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// / DestinationPolicy declares policies that determine how to handle traffic for a
// / destination service (load balancing policies, failure recovery policies such
// / as timeouts, retries, circuit breakers, etc).  Policies are applicable per
// / individual service versions. ONLY ONE policy can be defined per service version.
// /
// / Note that these policies are enforced on client-side connections or
// / requests, i.e., enforced when the service is opening a
// / connection/sending a request via the proxy to the destination.
type DestinationPolicy struct {
	// / REQUIRED. Service name for which the service version is defined. The
	// / value MUST be a fully-qualified domain name,
	// / e.g. "my-service.default.svc.cluster.local".
	Destination string `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	// / Service version destination identifier for the destination service.
	// / The identifier is qualified by the destination service name, e.g. version
	// / "env=prod" in "my-service.default.svc.cluster.local".
	// N.B. The map is used instead of pstruct due to lack of serialization support
	// in golang protobuf library (see https://github.com/golang/protobuf/pull/208)
	Tags map[string]string `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// / Load balancing policy
	LoadBalancing *LoadBalancing `protobuf:"bytes,3,opt,name=load_balancing,json=loadBalancing" json:"load_balancing,omitempty"`
	// / Circuit breaker policy
	CircuitBreaker *CircuitBreaker `protobuf:"bytes,4,opt,name=circuit_breaker,json=circuitBreaker" json:"circuit_breaker,omitempty"`
	// / Other custom policy implementations
	Custom *google_protobuf.Any `protobuf:"bytes,5,opt,name=custom" json:"custom,omitempty"`
}

func (m *DestinationPolicy) Reset()                    { *m = DestinationPolicy{} }
func (m *DestinationPolicy) String() string            { return proto.CompactTextString(m) }
func (*DestinationPolicy) ProtoMessage()               {}
func (*DestinationPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DestinationPolicy) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *DestinationPolicy) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DestinationPolicy) GetLoadBalancing() *LoadBalancing {
	if m != nil {
		return m.LoadBalancing
	}
	return nil
}

func (m *DestinationPolicy) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

func (m *DestinationPolicy) GetCustom() *google_protobuf.Any {
	if m != nil {
		return m.Custom
	}
	return nil
}

// / Route rule provides a custom routing policy based on the source and
// / destination service versions and connection/request metadata.  The rule must
// / provide a set of conditions for each protocol (TCP, UDP, HTTP) that the
// / destination service exposes on its ports. The rule applies only to the ports
// / on the destination service for which it provides protocol-specific match
// / condition, e.g. if the rule does not specify TCP condition, the rule does
// / not apply to TCP traffic towards the destination service.
type RouteRule struct {
	// / REQUIRED: Destination uniquely identifies the destination associated
	// / with this routing rule.  This field is applicable for hostname-based
	// / resolution for HTTP traffic as well as IP-based resolution for
	// / TCP/UDP traffic. The value MUST be a fully-qualified domain name,
	// / e.g. "my-service.default.svc.cluster.local".
	Destination string `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	// / Precedence is used to disambiguate the order of application of rules
	// / for the same destination service. A higher number takes priority. If
	// / not specified, the value is assumed to be 0.  The order of
	// / application for rules with the same precedence is unspecified.
	Precedence int32 `protobuf:"varint,2,opt,name=precedence" json:"precedence,omitempty"`
	// / Optional match condtions to be satisfied for the route rule to be
	// / activated. If match is omitted, the route rule applies only to HTTP
	// / traffic.
	Match *MatchCondition `protobuf:"bytes,3,opt,name=match" json:"match,omitempty"`
	// / Each routing rule is associated with one or more service version destinations
	// / (see glossary in beginning of document). Weights associated with the service
	// / version determine the proportion of traffic it receives.
	Route []*DestinationWeight `protobuf:"bytes,4,rep,name=route" json:"route,omitempty"`
	// / Timeout policy for HTTP requests.
	HttpReqTimeout *HTTPTimeout `protobuf:"bytes,5,opt,name=http_req_timeout,json=httpReqTimeout" json:"http_req_timeout,omitempty"`
	// / Retry policy for HTTP requests.
	HttpReqRetries *HTTPRetry `protobuf:"bytes,6,opt,name=http_req_retries,json=httpReqRetries" json:"http_req_retries,omitempty"`
	// /L7 fault injection policy applies to Http traffic
	HttpFault *HTTPFaultInjection `protobuf:"bytes,7,opt,name=http_fault,json=httpFault" json:"http_fault,omitempty"`
	// /@exclude L4 fault injection policy applies to Tcp/Udp (not Http) traffic
	L4Fault *L4FaultInjection `protobuf:"bytes,8,opt,name=l4_fault,json=l4Fault" json:"l4_fault,omitempty"`
}

func (m *RouteRule) Reset()                    { *m = RouteRule{} }
func (m *RouteRule) String() string            { return proto.CompactTextString(m) }
func (*RouteRule) ProtoMessage()               {}
func (*RouteRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RouteRule) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *RouteRule) GetPrecedence() int32 {
	if m != nil {
		return m.Precedence
	}
	return 0
}

func (m *RouteRule) GetMatch() *MatchCondition {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *RouteRule) GetRoute() []*DestinationWeight {
	if m != nil {
		return m.Route
	}
	return nil
}

func (m *RouteRule) GetHttpReqTimeout() *HTTPTimeout {
	if m != nil {
		return m.HttpReqTimeout
	}
	return nil
}

func (m *RouteRule) GetHttpReqRetries() *HTTPRetry {
	if m != nil {
		return m.HttpReqRetries
	}
	return nil
}

func (m *RouteRule) GetHttpFault() *HTTPFaultInjection {
	if m != nil {
		return m.HttpFault
	}
	return nil
}

func (m *RouteRule) GetL4Fault() *L4FaultInjection {
	if m != nil {
		return m.L4Fault
	}
	return nil
}

// / Match condition specifies a set of criterion to be met in order for the
// / route rule to be applied to the connection or HTTP request.  The
// / condition provides distinct set of conditions for each protocol with
// / the intention that conditions apply only to the service ports that
// / match the protocol.
type MatchCondition struct {
	// / Identifies the service initiating a connection or a request by its
	// / name. If specified, name MUST BE a fully qualified domain name such
	// / as foo.bar.com
	Source string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// / Identifies the source service version. The identifier is interpreted
	// / by the platform to match a service version for the source service.
	// N.B. The map is used instead of pstruct due to lack of serialization support
	// in golang protobuf library (see https://github.com/golang/protobuf/pull/208)
	SourceTags map[string]string `protobuf:"bytes,2,rep,name=source_tags,json=sourceTags" json:"source_tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// / Set of layer 4 match conditions based on the IP ranges. INCOMPLETE implementation
	Tcp *L4MatchAttributes `protobuf:"bytes,3,opt,name=tcp" json:"tcp,omitempty"`
	// Set of layer 4 match conditions based on the IP ranges
	Udp *L4MatchAttributes `protobuf:"bytes,4,opt,name=udp" json:"udp,omitempty"`
	// / Set of HTTP match conditions based on HTTP/1.1, HTTP/2, GRPC request metadata,
	// / such as "uri", "scheme", "authority".
	// / The header keys are case-insensitive.
	HttpHeaders map[string]*StringMatch `protobuf:"bytes,5,rep,name=http_headers,json=httpHeaders" json:"http_headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MatchCondition) Reset()                    { *m = MatchCondition{} }
func (m *MatchCondition) String() string            { return proto.CompactTextString(m) }
func (*MatchCondition) ProtoMessage()               {}
func (*MatchCondition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *MatchCondition) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *MatchCondition) GetSourceTags() map[string]string {
	if m != nil {
		return m.SourceTags
	}
	return nil
}

func (m *MatchCondition) GetTcp() *L4MatchAttributes {
	if m != nil {
		return m.Tcp
	}
	return nil
}

func (m *MatchCondition) GetUdp() *L4MatchAttributes {
	if m != nil {
		return m.Udp
	}
	return nil
}

func (m *MatchCondition) GetHttpHeaders() map[string]*StringMatch {
	if m != nil {
		return m.HttpHeaders
	}
	return nil
}

// / Each routing rule is associated with one or more service versions (see
// / glossary in beginning of document). Weights associated with the version
// / determine the proportion of traffic it receives.
type DestinationWeight struct {
	// / Destination uniquely identifies the destination service. If not
	// / specified, the value is inherited from the parent route rule. Value
	// / must be in fully qualified domain name format (e.g.,
	// / "my-service.default.svc.cluster.local").
	Destination string `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	// / Service version identifier for the destination service.
	// N.B. The map is used instead of pstruct due to lack of serialization support
	// in golang protobuf library (see https://github.com/golang/protobuf/pull/208)
	Tags map[string]string `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// / The proportion of traffic to be forwarded to the service version. Max
	// / is 100. Sum of weights across destinations should add up to 100. If
	// / there is only destination in a rule, the weight value is assumed to
	// / be 100.
	Weight int32 `protobuf:"varint,3,opt,name=weight" json:"weight,omitempty"`
}

func (m *DestinationWeight) Reset()                    { *m = DestinationWeight{} }
func (m *DestinationWeight) String() string            { return proto.CompactTextString(m) }
func (*DestinationWeight) ProtoMessage()               {}
func (*DestinationWeight) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DestinationWeight) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *DestinationWeight) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DestinationWeight) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// / L4 connection match attributes. Note that L4 connection matching
// / support is incomplete.
type L4MatchAttributes struct {
	// / IPv4 or IPv6 ip address with optional subnet. E.g., a.b.c.d/xx form or
	// / just a.b.c.d
	SourceSubnet []string `protobuf:"bytes,1,rep,name=source_subnet,json=sourceSubnet" json:"source_subnet,omitempty"`
	// / IPv4 or IPv6 ip address of destination with optional subnet.
	// / E.g., a.b.c.d/xx form or just a.b.c.d. This is only valid when the destination
	// / service has several IPs and the application explicitly specifies a particular IP.
	DestinationSubnet []string `protobuf:"bytes,2,rep,name=destination_subnet,json=destinationSubnet" json:"destination_subnet,omitempty"`
}

func (m *L4MatchAttributes) Reset()                    { *m = L4MatchAttributes{} }
func (m *L4MatchAttributes) String() string            { return proto.CompactTextString(m) }
func (*L4MatchAttributes) ProtoMessage()               {}
func (*L4MatchAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *L4MatchAttributes) GetSourceSubnet() []string {
	if m != nil {
		return m.SourceSubnet
	}
	return nil
}

func (m *L4MatchAttributes) GetDestinationSubnet() []string {
	if m != nil {
		return m.DestinationSubnet
	}
	return nil
}

// / Describes how to matches a given string (exact match, prefix-based
// / match or posix style regex based match). Match is case-sensitive. NOTE:
// / use of regex depends on the specific proxy implementation.
type StringMatch struct {
	// Types that are valid to be assigned to MatchType:
	//	*StringMatch_Exact
	//	*StringMatch_Prefix
	//	*StringMatch_Regex
	MatchType isStringMatch_MatchType `protobuf_oneof:"match_type"`
}

func (m *StringMatch) Reset()                    { *m = StringMatch{} }
func (m *StringMatch) String() string            { return proto.CompactTextString(m) }
func (*StringMatch) ProtoMessage()               {}
func (*StringMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isStringMatch_MatchType interface {
	isStringMatch_MatchType()
}

type StringMatch_Exact struct {
	Exact string `protobuf:"bytes,1,opt,name=exact,oneof"`
}
type StringMatch_Prefix struct {
	Prefix string `protobuf:"bytes,2,opt,name=prefix,oneof"`
}
type StringMatch_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,oneof"`
}

func (*StringMatch_Exact) isStringMatch_MatchType()  {}
func (*StringMatch_Prefix) isStringMatch_MatchType() {}
func (*StringMatch_Regex) isStringMatch_MatchType()  {}

func (m *StringMatch) GetMatchType() isStringMatch_MatchType {
	if m != nil {
		return m.MatchType
	}
	return nil
}

func (m *StringMatch) GetExact() string {
	if x, ok := m.GetMatchType().(*StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *StringMatch) GetPrefix() string {
	if x, ok := m.GetMatchType().(*StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *StringMatch) GetRegex() string {
	if x, ok := m.GetMatchType().(*StringMatch_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StringMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StringMatch_OneofMarshaler, _StringMatch_OneofUnmarshaler, _StringMatch_OneofSizer, []interface{}{
		(*StringMatch_Exact)(nil),
		(*StringMatch_Prefix)(nil),
		(*StringMatch_Regex)(nil),
	}
}

func _StringMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Exact)
	case *StringMatch_Prefix:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Prefix)
	case *StringMatch_Regex:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Regex)
	case nil:
	default:
		return fmt.Errorf("StringMatch.MatchType has unexpected type %T", x)
	}
	return nil
}

func _StringMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StringMatch)
	switch tag {
	case 1: // match_type.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Exact{x}
		return true, err
	case 2: // match_type.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Prefix{x}
		return true, err
	case 3: // match_type.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Regex{x}
		return true, err
	default:
		return false, nil
	}
}

func _StringMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *StringMatch_Prefix:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case *StringMatch_Regex:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// / Load balancing policy to use when forwarding traffic.
type LoadBalancing struct {
	// Types that are valid to be assigned to LbPolicy:
	//	*LoadBalancing_Name
	//	*LoadBalancing_Custom
	LbPolicy isLoadBalancing_LbPolicy `protobuf_oneof:"lb_policy"`
}

func (m *LoadBalancing) Reset()                    { *m = LoadBalancing{} }
func (m *LoadBalancing) String() string            { return proto.CompactTextString(m) }
func (*LoadBalancing) ProtoMessage()               {}
func (*LoadBalancing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isLoadBalancing_LbPolicy interface {
	isLoadBalancing_LbPolicy()
}

type LoadBalancing_Name struct {
	Name LoadBalancing_SimpleLBPolicy `protobuf:"varint,1,opt,name=name,enum=istio.proxy.v1alpha.config.LoadBalancing_SimpleLBPolicy,oneof"`
}
type LoadBalancing_Custom struct {
	Custom *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom,oneof"`
}

func (*LoadBalancing_Name) isLoadBalancing_LbPolicy()   {}
func (*LoadBalancing_Custom) isLoadBalancing_LbPolicy() {}

func (m *LoadBalancing) GetLbPolicy() isLoadBalancing_LbPolicy {
	if m != nil {
		return m.LbPolicy
	}
	return nil
}

func (m *LoadBalancing) GetName() LoadBalancing_SimpleLBPolicy {
	if x, ok := m.GetLbPolicy().(*LoadBalancing_Name); ok {
		return x.Name
	}
	return LoadBalancing_ROUND_ROBIN
}

func (m *LoadBalancing) GetCustom() *google_protobuf.Any {
	if x, ok := m.GetLbPolicy().(*LoadBalancing_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LoadBalancing) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LoadBalancing_OneofMarshaler, _LoadBalancing_OneofUnmarshaler, _LoadBalancing_OneofSizer, []interface{}{
		(*LoadBalancing_Name)(nil),
		(*LoadBalancing_Custom)(nil),
	}
}

func _LoadBalancing_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LoadBalancing)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancing_Name:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Name))
	case *LoadBalancing_Custom:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Custom); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LoadBalancing.LbPolicy has unexpected type %T", x)
	}
	return nil
}

func _LoadBalancing_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LoadBalancing)
	switch tag {
	case 1: // lb_policy.name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.LbPolicy = &LoadBalancing_Name{LoadBalancing_SimpleLBPolicy(x)}
		return true, err
	case 2: // lb_policy.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.LbPolicy = &LoadBalancing_Custom{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LoadBalancing_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LoadBalancing)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancing_Name:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Name))
	case *LoadBalancing_Custom:
		s := proto.Size(x.Custom)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// / Request timeout: wait time until a response is received. Does not
// / indicate the time for the entire response to arrive.
type HTTPTimeout struct {
	// Types that are valid to be assigned to TimeoutPolicy:
	//	*HTTPTimeout_SimpleTimeout
	//	*HTTPTimeout_Custom
	TimeoutPolicy isHTTPTimeout_TimeoutPolicy `protobuf_oneof:"timeout_policy"`
}

func (m *HTTPTimeout) Reset()                    { *m = HTTPTimeout{} }
func (m *HTTPTimeout) String() string            { return proto.CompactTextString(m) }
func (*HTTPTimeout) ProtoMessage()               {}
func (*HTTPTimeout) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isHTTPTimeout_TimeoutPolicy interface {
	isHTTPTimeout_TimeoutPolicy()
}

type HTTPTimeout_SimpleTimeout struct {
	SimpleTimeout *HTTPTimeout_SimpleTimeoutPolicy `protobuf:"bytes,1,opt,name=simple_timeout,json=simpleTimeout,oneof"`
}
type HTTPTimeout_Custom struct {
	Custom *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom,oneof"`
}

func (*HTTPTimeout_SimpleTimeout) isHTTPTimeout_TimeoutPolicy() {}
func (*HTTPTimeout_Custom) isHTTPTimeout_TimeoutPolicy()        {}

func (m *HTTPTimeout) GetTimeoutPolicy() isHTTPTimeout_TimeoutPolicy {
	if m != nil {
		return m.TimeoutPolicy
	}
	return nil
}

func (m *HTTPTimeout) GetSimpleTimeout() *HTTPTimeout_SimpleTimeoutPolicy {
	if x, ok := m.GetTimeoutPolicy().(*HTTPTimeout_SimpleTimeout); ok {
		return x.SimpleTimeout
	}
	return nil
}

func (m *HTTPTimeout) GetCustom() *google_protobuf.Any {
	if x, ok := m.GetTimeoutPolicy().(*HTTPTimeout_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HTTPTimeout) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HTTPTimeout_OneofMarshaler, _HTTPTimeout_OneofUnmarshaler, _HTTPTimeout_OneofSizer, []interface{}{
		(*HTTPTimeout_SimpleTimeout)(nil),
		(*HTTPTimeout_Custom)(nil),
	}
}

func _HTTPTimeout_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HTTPTimeout)
	// timeout_policy
	switch x := m.TimeoutPolicy.(type) {
	case *HTTPTimeout_SimpleTimeout:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleTimeout); err != nil {
			return err
		}
	case *HTTPTimeout_Custom:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Custom); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HTTPTimeout.TimeoutPolicy has unexpected type %T", x)
	}
	return nil
}

func _HTTPTimeout_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HTTPTimeout)
	switch tag {
	case 1: // timeout_policy.simple_timeout
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HTTPTimeout_SimpleTimeoutPolicy)
		err := b.DecodeMessage(msg)
		m.TimeoutPolicy = &HTTPTimeout_SimpleTimeout{msg}
		return true, err
	case 2: // timeout_policy.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.TimeoutPolicy = &HTTPTimeout_Custom{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HTTPTimeout_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HTTPTimeout)
	// timeout_policy
	switch x := m.TimeoutPolicy.(type) {
	case *HTTPTimeout_SimpleTimeout:
		s := proto.Size(x.SimpleTimeout)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HTTPTimeout_Custom:
		s := proto.Size(x.Custom)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HTTPTimeout_SimpleTimeoutPolicy struct {
	// / Timeout for a HTTP request. Includes retries as well. Unit is in
	// / floating point seconds. Default 15 seconds. Specified in
	// / seconds.nanoseconds format
	TimeoutSeconds float64 `protobuf:"fixed64,1,opt,name=timeout_seconds,json=timeoutSeconds" json:"timeout_seconds,omitempty"`
	// / Downstream service could specify timeout via Http header to the
	// / proxy, if the proxy supports such a feature.
	OverrideHeaderName string `protobuf:"bytes,2,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HTTPTimeout_SimpleTimeoutPolicy) Reset()         { *m = HTTPTimeout_SimpleTimeoutPolicy{} }
func (m *HTTPTimeout_SimpleTimeoutPolicy) String() string { return proto.CompactTextString(m) }
func (*HTTPTimeout_SimpleTimeoutPolicy) ProtoMessage()    {}
func (*HTTPTimeout_SimpleTimeoutPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{8, 0}
}

func (m *HTTPTimeout_SimpleTimeoutPolicy) GetTimeoutSeconds() float64 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

func (m *HTTPTimeout_SimpleTimeoutPolicy) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// / Retry policy to use when a request fails.
type HTTPRetry struct {
	// Types that are valid to be assigned to RetryPolicy:
	//	*HTTPRetry_SimpleRetry
	//	*HTTPRetry_Custom
	RetryPolicy isHTTPRetry_RetryPolicy `protobuf_oneof:"retry_policy"`
}

func (m *HTTPRetry) Reset()                    { *m = HTTPRetry{} }
func (m *HTTPRetry) String() string            { return proto.CompactTextString(m) }
func (*HTTPRetry) ProtoMessage()               {}
func (*HTTPRetry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isHTTPRetry_RetryPolicy interface {
	isHTTPRetry_RetryPolicy()
}

type HTTPRetry_SimpleRetry struct {
	SimpleRetry *HTTPRetry_SimpleRetryPolicy `protobuf:"bytes,1,opt,name=simple_retry,json=simpleRetry,oneof"`
}
type HTTPRetry_Custom struct {
	Custom *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom,oneof"`
}

func (*HTTPRetry_SimpleRetry) isHTTPRetry_RetryPolicy() {}
func (*HTTPRetry_Custom) isHTTPRetry_RetryPolicy()      {}

func (m *HTTPRetry) GetRetryPolicy() isHTTPRetry_RetryPolicy {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *HTTPRetry) GetSimpleRetry() *HTTPRetry_SimpleRetryPolicy {
	if x, ok := m.GetRetryPolicy().(*HTTPRetry_SimpleRetry); ok {
		return x.SimpleRetry
	}
	return nil
}

func (m *HTTPRetry) GetCustom() *google_protobuf.Any {
	if x, ok := m.GetRetryPolicy().(*HTTPRetry_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HTTPRetry) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HTTPRetry_OneofMarshaler, _HTTPRetry_OneofUnmarshaler, _HTTPRetry_OneofSizer, []interface{}{
		(*HTTPRetry_SimpleRetry)(nil),
		(*HTTPRetry_Custom)(nil),
	}
}

func _HTTPRetry_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HTTPRetry)
	// retry_policy
	switch x := m.RetryPolicy.(type) {
	case *HTTPRetry_SimpleRetry:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleRetry); err != nil {
			return err
		}
	case *HTTPRetry_Custom:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Custom); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HTTPRetry.RetryPolicy has unexpected type %T", x)
	}
	return nil
}

func _HTTPRetry_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HTTPRetry)
	switch tag {
	case 1: // retry_policy.simple_retry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HTTPRetry_SimpleRetryPolicy)
		err := b.DecodeMessage(msg)
		m.RetryPolicy = &HTTPRetry_SimpleRetry{msg}
		return true, err
	case 2: // retry_policy.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.RetryPolicy = &HTTPRetry_Custom{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HTTPRetry_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HTTPRetry)
	// retry_policy
	switch x := m.RetryPolicy.(type) {
	case *HTTPRetry_SimpleRetry:
		s := proto.Size(x.SimpleRetry)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HTTPRetry_Custom:
		s := proto.Size(x.Custom)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HTTPRetry_SimpleRetryPolicy struct {
	// / Number of retries for a given request. The interval between retries
	// / will be determined automatically (25ms+). Actual number of retries
	// / attempted depends on the http_timeout
	Attempts int32 `protobuf:"varint,1,opt,name=attempts" json:"attempts,omitempty"`
	// / Downstream Service could specify retry attempts via Http header to
	// / the proxy, if the proxy supports such a feature.
	OverrideHeaderName string `protobuf:"bytes,2,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HTTPRetry_SimpleRetryPolicy) Reset()                    { *m = HTTPRetry_SimpleRetryPolicy{} }
func (m *HTTPRetry_SimpleRetryPolicy) String() string            { return proto.CompactTextString(m) }
func (*HTTPRetry_SimpleRetryPolicy) ProtoMessage()               {}
func (*HTTPRetry_SimpleRetryPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *HTTPRetry_SimpleRetryPolicy) GetAttempts() int32 {
	if m != nil {
		return m.Attempts
	}
	return 0
}

func (m *HTTPRetry_SimpleRetryPolicy) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// / Circuit breaker configuration.
type CircuitBreaker struct {
	// Types that are valid to be assigned to CbPolicy:
	//	*CircuitBreaker_SimpleCb
	//	*CircuitBreaker_Custom
	CbPolicy isCircuitBreaker_CbPolicy `protobuf_oneof:"cb_policy"`
}

func (m *CircuitBreaker) Reset()                    { *m = CircuitBreaker{} }
func (m *CircuitBreaker) String() string            { return proto.CompactTextString(m) }
func (*CircuitBreaker) ProtoMessage()               {}
func (*CircuitBreaker) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isCircuitBreaker_CbPolicy interface {
	isCircuitBreaker_CbPolicy()
}

type CircuitBreaker_SimpleCb struct {
	SimpleCb *CircuitBreaker_SimpleCircuitBreakerPolicy `protobuf:"bytes,1,opt,name=simple_cb,json=simpleCb,oneof"`
}
type CircuitBreaker_Custom struct {
	Custom *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom,oneof"`
}

func (*CircuitBreaker_SimpleCb) isCircuitBreaker_CbPolicy() {}
func (*CircuitBreaker_Custom) isCircuitBreaker_CbPolicy()   {}

func (m *CircuitBreaker) GetCbPolicy() isCircuitBreaker_CbPolicy {
	if m != nil {
		return m.CbPolicy
	}
	return nil
}

func (m *CircuitBreaker) GetSimpleCb() *CircuitBreaker_SimpleCircuitBreakerPolicy {
	if x, ok := m.GetCbPolicy().(*CircuitBreaker_SimpleCb); ok {
		return x.SimpleCb
	}
	return nil
}

func (m *CircuitBreaker) GetCustom() *google_protobuf.Any {
	if x, ok := m.GetCbPolicy().(*CircuitBreaker_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CircuitBreaker) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CircuitBreaker_OneofMarshaler, _CircuitBreaker_OneofUnmarshaler, _CircuitBreaker_OneofSizer, []interface{}{
		(*CircuitBreaker_SimpleCb)(nil),
		(*CircuitBreaker_Custom)(nil),
	}
}

func _CircuitBreaker_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CircuitBreaker)
	// cb_policy
	switch x := m.CbPolicy.(type) {
	case *CircuitBreaker_SimpleCb:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleCb); err != nil {
			return err
		}
	case *CircuitBreaker_Custom:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Custom); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CircuitBreaker.CbPolicy has unexpected type %T", x)
	}
	return nil
}

func _CircuitBreaker_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CircuitBreaker)
	switch tag {
	case 1: // cb_policy.simple_cb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CircuitBreaker_SimpleCircuitBreakerPolicy)
		err := b.DecodeMessage(msg)
		m.CbPolicy = &CircuitBreaker_SimpleCb{msg}
		return true, err
	case 2: // cb_policy.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.CbPolicy = &CircuitBreaker_Custom{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CircuitBreaker_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CircuitBreaker)
	// cb_policy
	switch x := m.CbPolicy.(type) {
	case *CircuitBreaker_SimpleCb:
		s := proto.Size(x.SimpleCb)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CircuitBreaker_Custom:
		s := proto.Size(x.Custom)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CircuitBreaker_SimpleCircuitBreakerPolicy struct {
	// / Maximum number of connections to a backend.
	MaxConnections int32 `protobuf:"varint,1,opt,name=max_connections,json=maxConnections" json:"max_connections,omitempty"`
	// / Maximum number of pending requests to a backend.
	HttpMaxPendingRequests int32 `protobuf:"varint,2,opt,name=http_max_pending_requests,json=httpMaxPendingRequests" json:"http_max_pending_requests,omitempty"`
	// / Maximum number of requests to a backend.
	HttpMaxRequests int32 `protobuf:"varint,3,opt,name=http_max_requests,json=httpMaxRequests" json:"http_max_requests,omitempty"`
	// / Minimum time the circuit will be closed. In floating point seconds format.
	SleepWindowSeconds float64 `protobuf:"fixed64,4,opt,name=sleep_window_seconds,json=sleepWindowSeconds" json:"sleep_window_seconds,omitempty"`
	// / Number of 5XX errors before circuit is opened.
	HttpConsecutiveErrors int32 `protobuf:"varint,5,opt,name=http_consecutive_errors,json=httpConsecutiveErrors" json:"http_consecutive_errors,omitempty"`
	// / Interval for checking state of hystrix circuit.
	HttpDetectionIntervalSeconds float64 `protobuf:"fixed64,6,opt,name=http_detection_interval_seconds,json=httpDetectionIntervalSeconds" json:"http_detection_interval_seconds,omitempty"`
	// / Maximum number of requests per connection to a backend.
	HttpMaxRequestsPerConnection int32 `protobuf:"varint,7,opt,name=http_max_requests_per_connection,json=httpMaxRequestsPerConnection" json:"http_max_requests_per_connection,omitempty"`
	// / Maximum % of hosts in the destination service that can be ejected due to circuit breaking. Defaults to 10%.
	HttpMaxEjectionPercent int32 `protobuf:"varint,8,opt,name=http_max_ejection_percent,json=httpMaxEjectionPercent" json:"http_max_ejection_percent,omitempty"`
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) Reset() {
	*m = CircuitBreaker_SimpleCircuitBreakerPolicy{}
}
func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) String() string { return proto.CompactTextString(m) }
func (*CircuitBreaker_SimpleCircuitBreakerPolicy) ProtoMessage()    {}
func (*CircuitBreaker_SimpleCircuitBreakerPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0}
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetMaxConnections() int32 {
	if m != nil {
		return m.MaxConnections
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpMaxPendingRequests() int32 {
	if m != nil {
		return m.HttpMaxPendingRequests
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpMaxRequests() int32 {
	if m != nil {
		return m.HttpMaxRequests
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetSleepWindowSeconds() float64 {
	if m != nil {
		return m.SleepWindowSeconds
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpConsecutiveErrors() int32 {
	if m != nil {
		return m.HttpConsecutiveErrors
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpDetectionIntervalSeconds() float64 {
	if m != nil {
		return m.HttpDetectionIntervalSeconds
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpMaxRequestsPerConnection() int32 {
	if m != nil {
		return m.HttpMaxRequestsPerConnection
	}
	return 0
}

func (m *CircuitBreaker_SimpleCircuitBreakerPolicy) GetHttpMaxEjectionPercent() int32 {
	if m != nil {
		return m.HttpMaxEjectionPercent
	}
	return 0
}

// / Faults can be injected into the API calls by the proxy, for testing the
// / failure recovery capabilities of downstream services.  Faults include
// / aborting the Http request from downstream service, delaying the proxying of
// / requests, or both. MUST specify either delay or abort or both.
type HTTPFaultInjection struct {
	// / Delay requests before forwarding, emulating various failures such as
	// / network issues, overloaded upstream service, etc.
	Delay *HTTPFaultInjection_Delay `protobuf:"bytes,1,opt,name=delay" json:"delay,omitempty"`
	// / Abort Http request attempts and return error codes back to downstream
	// / service, giving the impression that the upstream service is faulty.
	// / N.B. Both delay and abort can be specified simultaneously. Delay and
	// / Abort are independent of one another. For e.g., if Delay is restricted
	// / to 5% of requests while Abort is restricted to 10% of requests, the
	// / 10% in abort specification applies to all requests directed to the
	// / service. It may be the case that one or more requests being aborted
	// / were also delayed.
	Abort *HTTPFaultInjection_Abort `protobuf:"bytes,2,opt,name=abort" json:"abort,omitempty"`
}

func (m *HTTPFaultInjection) Reset()                    { *m = HTTPFaultInjection{} }
func (m *HTTPFaultInjection) String() string            { return proto.CompactTextString(m) }
func (*HTTPFaultInjection) ProtoMessage()               {}
func (*HTTPFaultInjection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *HTTPFaultInjection) GetDelay() *HTTPFaultInjection_Delay {
	if m != nil {
		return m.Delay
	}
	return nil
}

func (m *HTTPFaultInjection) GetAbort() *HTTPFaultInjection_Abort {
	if m != nil {
		return m.Abort
	}
	return nil
}

// / MUST specify either a fixed delay or exponential delay. Exponential
// / delay is unsupported at the moment.
type HTTPFaultInjection_Delay struct {
	// / percentage of requests on which the delay will be injected
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// Types that are valid to be assigned to HttpDelayType:
	//	*HTTPFaultInjection_Delay_FixedDelaySeconds
	//	*HTTPFaultInjection_Delay_ExponentialDelaySeconds
	HttpDelayType isHTTPFaultInjection_Delay_HttpDelayType `protobuf_oneof:"http_delay_type"`
	// Specify delay duration as part of Http request.
	// TODO: The semantics and syntax of the headers is undefined.
	OverrideHeaderName string `protobuf:"bytes,4,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HTTPFaultInjection_Delay) Reset()                    { *m = HTTPFaultInjection_Delay{} }
func (m *HTTPFaultInjection_Delay) String() string            { return proto.CompactTextString(m) }
func (*HTTPFaultInjection_Delay) ProtoMessage()               {}
func (*HTTPFaultInjection_Delay) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

type isHTTPFaultInjection_Delay_HttpDelayType interface {
	isHTTPFaultInjection_Delay_HttpDelayType()
}

type HTTPFaultInjection_Delay_FixedDelaySeconds struct {
	FixedDelaySeconds float64 `protobuf:"fixed64,2,opt,name=fixed_delay_seconds,json=fixedDelaySeconds,oneof"`
}
type HTTPFaultInjection_Delay_ExponentialDelaySeconds struct {
	ExponentialDelaySeconds float64 `protobuf:"fixed64,3,opt,name=exponential_delay_seconds,json=exponentialDelaySeconds,oneof"`
}

func (*HTTPFaultInjection_Delay_FixedDelaySeconds) isHTTPFaultInjection_Delay_HttpDelayType()       {}
func (*HTTPFaultInjection_Delay_ExponentialDelaySeconds) isHTTPFaultInjection_Delay_HttpDelayType() {}

func (m *HTTPFaultInjection_Delay) GetHttpDelayType() isHTTPFaultInjection_Delay_HttpDelayType {
	if m != nil {
		return m.HttpDelayType
	}
	return nil
}

func (m *HTTPFaultInjection_Delay) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *HTTPFaultInjection_Delay) GetFixedDelaySeconds() float64 {
	if x, ok := m.GetHttpDelayType().(*HTTPFaultInjection_Delay_FixedDelaySeconds); ok {
		return x.FixedDelaySeconds
	}
	return 0
}

func (m *HTTPFaultInjection_Delay) GetExponentialDelaySeconds() float64 {
	if x, ok := m.GetHttpDelayType().(*HTTPFaultInjection_Delay_ExponentialDelaySeconds); ok {
		return x.ExponentialDelaySeconds
	}
	return 0
}

func (m *HTTPFaultInjection_Delay) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HTTPFaultInjection_Delay) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HTTPFaultInjection_Delay_OneofMarshaler, _HTTPFaultInjection_Delay_OneofUnmarshaler, _HTTPFaultInjection_Delay_OneofSizer, []interface{}{
		(*HTTPFaultInjection_Delay_FixedDelaySeconds)(nil),
		(*HTTPFaultInjection_Delay_ExponentialDelaySeconds)(nil),
	}
}

func _HTTPFaultInjection_Delay_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HTTPFaultInjection_Delay)
	// http_delay_type
	switch x := m.HttpDelayType.(type) {
	case *HTTPFaultInjection_Delay_FixedDelaySeconds:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.FixedDelaySeconds))
	case *HTTPFaultInjection_Delay_ExponentialDelaySeconds:
		b.EncodeVarint(3<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.ExponentialDelaySeconds))
	case nil:
	default:
		return fmt.Errorf("HTTPFaultInjection_Delay.HttpDelayType has unexpected type %T", x)
	}
	return nil
}

func _HTTPFaultInjection_Delay_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HTTPFaultInjection_Delay)
	switch tag {
	case 2: // http_delay_type.fixed_delay_seconds
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.HttpDelayType = &HTTPFaultInjection_Delay_FixedDelaySeconds{math.Float64frombits(x)}
		return true, err
	case 3: // http_delay_type.exponential_delay_seconds
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.HttpDelayType = &HTTPFaultInjection_Delay_ExponentialDelaySeconds{math.Float64frombits(x)}
		return true, err
	default:
		return false, nil
	}
}

func _HTTPFaultInjection_Delay_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HTTPFaultInjection_Delay)
	// http_delay_type
	switch x := m.HttpDelayType.(type) {
	case *HTTPFaultInjection_Delay_FixedDelaySeconds:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case *HTTPFaultInjection_Delay_ExponentialDelaySeconds:
		n += proto.SizeVarint(3<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// / Abort Http request attempts and return error codes back to downstream
// / service.
type HTTPFaultInjection_Abort struct {
	// / percentage of requests to be aborted with the error code provided.
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// / Error code to use to abort the Http request. Requests can be aborted
	// / either with Http/1.1 status codes | http2 error codes or gRPC status
	// / codes. Only http_status based errors are supported at the moment.
	//
	// Types that are valid to be assigned to ErrorType:
	//	*HTTPFaultInjection_Abort_GrpcStatus
	//	*HTTPFaultInjection_Abort_Http2Error
	//	*HTTPFaultInjection_Abort_HttpStatus
	ErrorType isHTTPFaultInjection_Abort_ErrorType `protobuf_oneof:"error_type"`
	// Specify abort code as part of Http request.
	// TODO: The semantics and syntax of the headers is undefined.
	OverrideHeaderName string `protobuf:"bytes,5,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HTTPFaultInjection_Abort) Reset()                    { *m = HTTPFaultInjection_Abort{} }
func (m *HTTPFaultInjection_Abort) String() string            { return proto.CompactTextString(m) }
func (*HTTPFaultInjection_Abort) ProtoMessage()               {}
func (*HTTPFaultInjection_Abort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 1} }

type isHTTPFaultInjection_Abort_ErrorType interface {
	isHTTPFaultInjection_Abort_ErrorType()
}

type HTTPFaultInjection_Abort_GrpcStatus struct {
	GrpcStatus string `protobuf:"bytes,2,opt,name=grpc_status,json=grpcStatus,oneof"`
}
type HTTPFaultInjection_Abort_Http2Error struct {
	Http2Error string `protobuf:"bytes,3,opt,name=http2_error,json=http2Error,oneof"`
}
type HTTPFaultInjection_Abort_HttpStatus struct {
	HttpStatus int32 `protobuf:"varint,4,opt,name=http_status,json=httpStatus,oneof"`
}

func (*HTTPFaultInjection_Abort_GrpcStatus) isHTTPFaultInjection_Abort_ErrorType() {}
func (*HTTPFaultInjection_Abort_Http2Error) isHTTPFaultInjection_Abort_ErrorType() {}
func (*HTTPFaultInjection_Abort_HttpStatus) isHTTPFaultInjection_Abort_ErrorType() {}

func (m *HTTPFaultInjection_Abort) GetErrorType() isHTTPFaultInjection_Abort_ErrorType {
	if m != nil {
		return m.ErrorType
	}
	return nil
}

func (m *HTTPFaultInjection_Abort) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *HTTPFaultInjection_Abort) GetGrpcStatus() string {
	if x, ok := m.GetErrorType().(*HTTPFaultInjection_Abort_GrpcStatus); ok {
		return x.GrpcStatus
	}
	return ""
}

func (m *HTTPFaultInjection_Abort) GetHttp2Error() string {
	if x, ok := m.GetErrorType().(*HTTPFaultInjection_Abort_Http2Error); ok {
		return x.Http2Error
	}
	return ""
}

func (m *HTTPFaultInjection_Abort) GetHttpStatus() int32 {
	if x, ok := m.GetErrorType().(*HTTPFaultInjection_Abort_HttpStatus); ok {
		return x.HttpStatus
	}
	return 0
}

func (m *HTTPFaultInjection_Abort) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HTTPFaultInjection_Abort) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HTTPFaultInjection_Abort_OneofMarshaler, _HTTPFaultInjection_Abort_OneofUnmarshaler, _HTTPFaultInjection_Abort_OneofSizer, []interface{}{
		(*HTTPFaultInjection_Abort_GrpcStatus)(nil),
		(*HTTPFaultInjection_Abort_Http2Error)(nil),
		(*HTTPFaultInjection_Abort_HttpStatus)(nil),
	}
}

func _HTTPFaultInjection_Abort_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HTTPFaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *HTTPFaultInjection_Abort_GrpcStatus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.GrpcStatus)
	case *HTTPFaultInjection_Abort_Http2Error:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Http2Error)
	case *HTTPFaultInjection_Abort_HttpStatus:
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		return fmt.Errorf("HTTPFaultInjection_Abort.ErrorType has unexpected type %T", x)
	}
	return nil
}

func _HTTPFaultInjection_Abort_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HTTPFaultInjection_Abort)
	switch tag {
	case 2: // error_type.grpc_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ErrorType = &HTTPFaultInjection_Abort_GrpcStatus{x}
		return true, err
	case 3: // error_type.http2_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ErrorType = &HTTPFaultInjection_Abort_Http2Error{x}
		return true, err
	case 4: // error_type.http_status
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ErrorType = &HTTPFaultInjection_Abort_HttpStatus{int32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _HTTPFaultInjection_Abort_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HTTPFaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *HTTPFaultInjection_Abort_GrpcStatus:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.GrpcStatus)))
		n += len(x.GrpcStatus)
	case *HTTPFaultInjection_Abort_Http2Error:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Http2Error)))
		n += len(x.Http2Error)
	case *HTTPFaultInjection_Abort_HttpStatus:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// /@exclude Faults can be injected into the connections from downstream by the
// / proxy, for testing the failure recovery capabilities of downstream
// / services.  Faults include aborting the connection from downstream
// / service, delaying the proxying of connection to the destination
// / service, and throttling the bandwidth of the connection (either
// / end). Bandwidth throttling for failure testing should not be confused
// / with the rate limiting policy enforcement provided by the Mixer
// / component. L4 fault injection is not supported at the moment.
type L4FaultInjection struct {
	// / We first throttle (if set) and then terminate the connection.
	Throttle  *L4FaultInjection_Throttle  `protobuf:"bytes,1,opt,name=throttle" json:"throttle,omitempty"`
	Terminate *L4FaultInjection_Terminate `protobuf:"bytes,2,opt,name=terminate" json:"terminate,omitempty"`
}

func (m *L4FaultInjection) Reset()                    { *m = L4FaultInjection{} }
func (m *L4FaultInjection) String() string            { return proto.CompactTextString(m) }
func (*L4FaultInjection) ProtoMessage()               {}
func (*L4FaultInjection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *L4FaultInjection) GetThrottle() *L4FaultInjection_Throttle {
	if m != nil {
		return m.Throttle
	}
	return nil
}

func (m *L4FaultInjection) GetTerminate() *L4FaultInjection_Terminate {
	if m != nil {
		return m.Terminate
	}
	return nil
}

// / Bandwidth throttling for Tcp and Udp connections
type L4FaultInjection_Throttle struct {
	// / percentage of connections to throttle.
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// / bandwidth limit in "bits" per second between downstream and proxy
	DownstreamLimitBps int64 `protobuf:"varint,2,opt,name=downstream_limit_bps,json=downstreamLimitBps" json:"downstream_limit_bps,omitempty"`
	// / bandwidth limits in "bits" per second between proxy and upstream
	UpstreamLimitBps int64 `protobuf:"varint,3,opt,name=upstream_limit_bps,json=upstreamLimitBps" json:"upstream_limit_bps,omitempty"`
	// Types that are valid to be assigned to ThrottleAfter:
	//	*L4FaultInjection_Throttle_ThrottleAfterSeconds
	//	*L4FaultInjection_Throttle_ThrottleAfterBytes
	ThrottleAfter isL4FaultInjection_Throttle_ThrottleAfter `protobuf_oneof:"throttle_after"`
	// / Stop throttling after the given duration. If not set, the connection
	// / will be throttled for its lifetime.
	ThrottleForSeconds *google_protobuf1.DoubleValue `protobuf:"bytes,6,opt,name=throttle_for_seconds,json=throttleForSeconds" json:"throttle_for_seconds,omitempty"`
}

func (m *L4FaultInjection_Throttle) Reset()                    { *m = L4FaultInjection_Throttle{} }
func (m *L4FaultInjection_Throttle) String() string            { return proto.CompactTextString(m) }
func (*L4FaultInjection_Throttle) ProtoMessage()               {}
func (*L4FaultInjection_Throttle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

type isL4FaultInjection_Throttle_ThrottleAfter interface {
	isL4FaultInjection_Throttle_ThrottleAfter()
}

type L4FaultInjection_Throttle_ThrottleAfterSeconds struct {
	ThrottleAfterSeconds float64 `protobuf:"fixed64,4,opt,name=throttle_after_seconds,json=throttleAfterSeconds,oneof"`
}
type L4FaultInjection_Throttle_ThrottleAfterBytes struct {
	ThrottleAfterBytes float64 `protobuf:"fixed64,5,opt,name=throttle_after_bytes,json=throttleAfterBytes,oneof"`
}

func (*L4FaultInjection_Throttle_ThrottleAfterSeconds) isL4FaultInjection_Throttle_ThrottleAfter() {}
func (*L4FaultInjection_Throttle_ThrottleAfterBytes) isL4FaultInjection_Throttle_ThrottleAfter()   {}

func (m *L4FaultInjection_Throttle) GetThrottleAfter() isL4FaultInjection_Throttle_ThrottleAfter {
	if m != nil {
		return m.ThrottleAfter
	}
	return nil
}

func (m *L4FaultInjection_Throttle) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetDownstreamLimitBps() int64 {
	if m != nil {
		return m.DownstreamLimitBps
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetUpstreamLimitBps() int64 {
	if m != nil {
		return m.UpstreamLimitBps
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetThrottleAfterSeconds() float64 {
	if x, ok := m.GetThrottleAfter().(*L4FaultInjection_Throttle_ThrottleAfterSeconds); ok {
		return x.ThrottleAfterSeconds
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetThrottleAfterBytes() float64 {
	if x, ok := m.GetThrottleAfter().(*L4FaultInjection_Throttle_ThrottleAfterBytes); ok {
		return x.ThrottleAfterBytes
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetThrottleForSeconds() *google_protobuf1.DoubleValue {
	if m != nil {
		return m.ThrottleForSeconds
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*L4FaultInjection_Throttle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _L4FaultInjection_Throttle_OneofMarshaler, _L4FaultInjection_Throttle_OneofUnmarshaler, _L4FaultInjection_Throttle_OneofSizer, []interface{}{
		(*L4FaultInjection_Throttle_ThrottleAfterSeconds)(nil),
		(*L4FaultInjection_Throttle_ThrottleAfterBytes)(nil),
	}
}

func _L4FaultInjection_Throttle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*L4FaultInjection_Throttle)
	// throttle_after
	switch x := m.ThrottleAfter.(type) {
	case *L4FaultInjection_Throttle_ThrottleAfterSeconds:
		b.EncodeVarint(4<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.ThrottleAfterSeconds))
	case *L4FaultInjection_Throttle_ThrottleAfterBytes:
		b.EncodeVarint(5<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.ThrottleAfterBytes))
	case nil:
	default:
		return fmt.Errorf("L4FaultInjection_Throttle.ThrottleAfter has unexpected type %T", x)
	}
	return nil
}

func _L4FaultInjection_Throttle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*L4FaultInjection_Throttle)
	switch tag {
	case 4: // throttle_after.throttle_after_seconds
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ThrottleAfter = &L4FaultInjection_Throttle_ThrottleAfterSeconds{math.Float64frombits(x)}
		return true, err
	case 5: // throttle_after.throttle_after_bytes
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ThrottleAfter = &L4FaultInjection_Throttle_ThrottleAfterBytes{math.Float64frombits(x)}
		return true, err
	default:
		return false, nil
	}
}

func _L4FaultInjection_Throttle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*L4FaultInjection_Throttle)
	// throttle_after
	switch x := m.ThrottleAfter.(type) {
	case *L4FaultInjection_Throttle_ThrottleAfterSeconds:
		n += proto.SizeVarint(4<<3 | proto.WireFixed64)
		n += 8
	case *L4FaultInjection_Throttle_ThrottleAfterBytes:
		n += proto.SizeVarint(5<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// / Abruptly reset (terminate) the Tcp connection after it has been
// / established, emulating remote server crash or link failure.
type L4FaultInjection_Terminate struct {
	// / percentage of established Tcp connections to be terminated/reset
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// TODO: see if it makes sense to create a generic Duration type to
	// express time interval related configs.
	TerminateAfterSeconds float64 `protobuf:"fixed64,2,opt,name=terminate_after_seconds,json=terminateAfterSeconds" json:"terminate_after_seconds,omitempty"`
}

func (m *L4FaultInjection_Terminate) Reset()                    { *m = L4FaultInjection_Terminate{} }
func (m *L4FaultInjection_Terminate) String() string            { return proto.CompactTextString(m) }
func (*L4FaultInjection_Terminate) ProtoMessage()               {}
func (*L4FaultInjection_Terminate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 1} }

func (m *L4FaultInjection_Terminate) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *L4FaultInjection_Terminate) GetTerminateAfterSeconds() float64 {
	if m != nil {
		return m.TerminateAfterSeconds
	}
	return 0
}

func init() {
	proto.RegisterType((*ProxyMeshConfig)(nil), "istio.proxy.v1alpha.config.ProxyMeshConfig")
	proto.RegisterType((*DestinationPolicy)(nil), "istio.proxy.v1alpha.config.DestinationPolicy")
	proto.RegisterType((*RouteRule)(nil), "istio.proxy.v1alpha.config.RouteRule")
	proto.RegisterType((*MatchCondition)(nil), "istio.proxy.v1alpha.config.MatchCondition")
	proto.RegisterType((*DestinationWeight)(nil), "istio.proxy.v1alpha.config.DestinationWeight")
	proto.RegisterType((*L4MatchAttributes)(nil), "istio.proxy.v1alpha.config.L4MatchAttributes")
	proto.RegisterType((*StringMatch)(nil), "istio.proxy.v1alpha.config.StringMatch")
	proto.RegisterType((*LoadBalancing)(nil), "istio.proxy.v1alpha.config.LoadBalancing")
	proto.RegisterType((*HTTPTimeout)(nil), "istio.proxy.v1alpha.config.HTTPTimeout")
	proto.RegisterType((*HTTPTimeout_SimpleTimeoutPolicy)(nil), "istio.proxy.v1alpha.config.HTTPTimeout.SimpleTimeoutPolicy")
	proto.RegisterType((*HTTPRetry)(nil), "istio.proxy.v1alpha.config.HTTPRetry")
	proto.RegisterType((*HTTPRetry_SimpleRetryPolicy)(nil), "istio.proxy.v1alpha.config.HTTPRetry.SimpleRetryPolicy")
	proto.RegisterType((*CircuitBreaker)(nil), "istio.proxy.v1alpha.config.CircuitBreaker")
	proto.RegisterType((*CircuitBreaker_SimpleCircuitBreakerPolicy)(nil), "istio.proxy.v1alpha.config.CircuitBreaker.SimpleCircuitBreakerPolicy")
	proto.RegisterType((*HTTPFaultInjection)(nil), "istio.proxy.v1alpha.config.HTTPFaultInjection")
	proto.RegisterType((*HTTPFaultInjection_Delay)(nil), "istio.proxy.v1alpha.config.HTTPFaultInjection.Delay")
	proto.RegisterType((*HTTPFaultInjection_Abort)(nil), "istio.proxy.v1alpha.config.HTTPFaultInjection.Abort")
	proto.RegisterType((*L4FaultInjection)(nil), "istio.proxy.v1alpha.config.L4FaultInjection")
	proto.RegisterType((*L4FaultInjection_Throttle)(nil), "istio.proxy.v1alpha.config.L4FaultInjection.Throttle")
	proto.RegisterType((*L4FaultInjection_Terminate)(nil), "istio.proxy.v1alpha.config.L4FaultInjection.Terminate")
	proto.RegisterEnum("istio.proxy.v1alpha.config.LoadBalancing_SimpleLBPolicy", LoadBalancing_SimpleLBPolicy_name, LoadBalancing_SimpleLBPolicy_value)
}

func init() { proto.RegisterFile("cfg.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1628 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x57, 0xdd, 0x6e, 0xdb, 0xc8,
	0x15, 0xb6, 0x7e, 0xa8, 0x58, 0x47, 0xb6, 0x2c, 0x4d, 0x1c, 0x47, 0x11, 0x82, 0xd4, 0x55, 0x51,
	0xc4, 0x0d, 0x12, 0x25, 0x75, 0x53, 0x27, 0x4d, 0x1a, 0xb4, 0x96, 0xec, 0x54, 0x69, 0x6d, 0xd9,
	0x19, 0xb9, 0x0d, 0xd0, 0x3f, 0x82, 0x22, 0x47, 0x12, 0x37, 0x14, 0xc9, 0x0c, 0x87, 0xb6, 0xf4,
	0x0e, 0x0b, 0x6c, 0xae, 0xf6, 0x15, 0xf6, 0x5d, 0xf6, 0x32, 0x0b, 0xec, 0xcd, 0xde, 0xec, 0x1b,
	0xec, 0x2b, 0x2c, 0xe6, 0x87, 0x14, 0x25, 0xc5, 0x8a, 0x15, 0x60, 0xef, 0x34, 0xe7, 0x9c, 0xef,
	0xe3, 0x9c, 0x6f, 0xce, 0x9c, 0x39, 0x82, 0xbc, 0xd9, 0xeb, 0xd7, 0x7d, 0xea, 0x31, 0x0f, 0x55,
	0xed, 0x80, 0xd9, 0x1e, 0x5f, 0x8c, 0xc6, 0xf5, 0xf3, 0xdf, 0x1b, 0x8e, 0x3f, 0x30, 0xea, 0xa6,
	0xe7, 0xf6, 0xec, 0x7e, 0xf5, 0x56, 0xdf, 0xf3, 0xfa, 0x0e, 0x79, 0x28, 0x22, 0xbb, 0x61, 0xef,
	0xa1, 0xe1, 0x8e, 0x25, 0xac, 0x7a, 0x67, 0xd6, 0x75, 0x41, 0x0d, 0xdf, 0x27, 0x34, 0x90, 0xfe,
	0x5a, 0x19, 0x36, 0x4e, 0x39, 0xe5, 0x31, 0x09, 0x06, 0x4d, 0xc1, 0x56, 0x7b, 0x9f, 0x81, 0xf2,
	0x01, 0x09, 0x98, 0xed, 0x1a, 0xcc, 0xf6, 0xdc, 0x53, 0xcf, 0xb1, 0xcd, 0x31, 0xda, 0x86, 0x82,
	0x35, 0x31, 0x56, 0x52, 0xdb, 0xa9, 0x9d, 0x3c, 0x4e, 0x9a, 0xd0, 0x3f, 0x20, 0xcb, 0x8c, 0x7e,
	0x50, 0x49, 0x6f, 0x67, 0x76, 0x0a, 0xbb, 0x4f, 0xea, 0x97, 0x6f, 0xb8, 0x3e, 0x47, 0x5f, 0x3f,
	0x33, 0xfa, 0xc1, 0xa1, 0xcb, 0xe8, 0x18, 0x0b, 0x12, 0x74, 0x0a, 0x45, 0xc7, 0x33, 0x2c, 0xbd,
	0x6b, 0x38, 0x86, 0x6b, 0xda, 0x6e, 0xbf, 0x92, 0xd9, 0x4e, 0xed, 0x14, 0x76, 0x7f, 0xb7, 0x88,
	0xf6, 0xc8, 0x33, 0xac, 0x46, 0x04, 0xc0, 0xeb, 0x4e, 0x72, 0x89, 0x3a, 0xb0, 0x61, 0xda, 0xd4,
	0x0c, 0x6d, 0xa6, 0x77, 0x29, 0x31, 0xde, 0x12, 0x5a, 0xc9, 0x0a, 0xca, 0x7b, 0x8b, 0x28, 0x9b,
	0x12, 0xd2, 0x90, 0x08, 0x5c, 0x34, 0xa7, 0xd6, 0xe8, 0x3e, 0xe4, 0xcc, 0x30, 0x60, 0xde, 0xb0,
	0xa2, 0x09, 0xae, 0xcd, 0xba, 0xd4, 0xbb, 0x1e, 0xe9, 0x5d, 0xdf, 0x77, 0xc7, 0x58, 0xc5, 0x54,
	0x9f, 0x40, 0x3e, 0xce, 0x13, 0x95, 0x20, 0xf3, 0x96, 0x8c, 0x95, 0x90, 0xfc, 0x27, 0xda, 0x04,
	0xed, 0xdc, 0x70, 0x42, 0x52, 0x49, 0x0b, 0x9b, 0x5c, 0x3c, 0x4b, 0x3f, 0x4d, 0xd5, 0xde, 0x67,
	0x21, 0x8f, 0xbd, 0x90, 0x11, 0x1c, 0x3a, 0xe4, 0x0a, 0x47, 0x71, 0x07, 0xc0, 0xa7, 0xc4, 0x24,
	0x16, 0x71, 0x4d, 0x49, 0xa7, 0xe1, 0x84, 0x05, 0xfd, 0x15, 0xb4, 0xa1, 0xc1, 0xcc, 0x81, 0x12,
	0x75, 0xa1, 0x02, 0xc7, 0x3c, 0xb0, 0xe9, 0xb9, 0x96, 0xcd, 0xa9, 0xb1, 0x04, 0xa2, 0x26, 0x68,
	0x94, 0x6f, 0xa8, 0x92, 0x15, 0xa7, 0xfd, 0xe0, 0x8a, 0xa7, 0xfd, 0x86, 0xd8, 0xfd, 0x01, 0xc3,
	0x12, 0x8b, 0x5e, 0x43, 0x69, 0xc0, 0x98, 0xaf, 0x53, 0xf2, 0x4e, 0x67, 0xf6, 0x90, 0x78, 0x21,
	0x53, 0x3a, 0xde, 0x5d, 0xc4, 0xd7, 0x3a, 0x3b, 0x3b, 0x3d, 0x93, 0xe1, 0xb8, 0xc8, 0x09, 0x30,
	0x79, 0xa7, 0xd6, 0xe8, 0x24, 0x41, 0x49, 0x09, 0xa3, 0x36, 0x09, 0x2a, 0x39, 0x41, 0xf9, 0xdb,
	0x4f, 0x51, 0x62, 0xc2, 0xcb, 0x2f, 0x22, 0xc4, 0x12, 0x8c, 0x8e, 0x01, 0x04, 0x61, 0xcf, 0x08,
	0x1d, 0x56, 0xb9, 0x26, 0xa8, 0xea, 0x9f, 0xa2, 0x7a, 0xc9, 0x83, 0x5f, 0xb9, 0x5f, 0x10, 0x53,
	0x68, 0x96, 0xe7, 0x0c, 0xc2, 0x86, 0xfe, 0x06, 0xab, 0xce, 0x63, 0x45, 0xb6, 0x2a, 0xc8, 0xee,
	0x2f, 0xac, 0xe8, 0xc7, 0x33, 0x54, 0xd7, 0x1c, 0x69, 0xa9, 0x7d, 0x95, 0x85, 0xe2, 0xf4, 0xd1,
	0xa0, 0x2d, 0xc8, 0x05, 0x5e, 0x48, 0x4d, 0xa2, 0x4a, 0x42, 0xad, 0xd0, 0x7f, 0xa0, 0x20, 0x7f,
	0xe9, 0x89, 0xfb, 0xf9, 0xec, 0xea, 0x67, 0x5e, 0xef, 0x08, 0xf4, 0xe4, 0x8a, 0x42, 0x10, 0x1b,
	0xd0, 0x5f, 0x20, 0xc3, 0x4c, 0x5f, 0x15, 0xd2, 0x83, 0xc5, 0xb9, 0x08, 0xda, 0x7d, 0xc6, 0xa8,
	0xdd, 0x0d, 0x19, 0x09, 0x30, 0x47, 0x72, 0x82, 0xd0, 0xf2, 0xd5, 0x5d, 0x5c, 0x96, 0x20, 0xb4,
	0x7c, 0xf4, 0x7f, 0x58, 0x13, 0x27, 0x34, 0x20, 0x86, 0x45, 0x68, 0x50, 0xd1, 0x44, 0x7e, 0xcf,
	0x97, 0xc8, 0xaf, 0xc5, 0x98, 0xdf, 0x92, 0x68, 0x99, 0x60, 0x61, 0x30, 0xb1, 0x54, 0x5f, 0xc0,
	0xc6, 0x8c, 0x00, 0xcb, 0xdc, 0xdd, 0x6a, 0x1f, 0x4a, 0xb3, 0xfc, 0x1f, 0xc1, 0xbf, 0x48, 0xe2,
	0x3f, 0x51, 0xff, 0x1d, 0x46, 0x6d, 0xb7, 0x2f, 0x72, 0x48, 0x36, 0x89, 0xef, 0x52, 0x53, 0x7d,
	0x5b, 0x5e, 0xb5, 0x5f, 0xac, 0x6f, 0x4b, 0xfa, 0xb9, 0xbe, 0xbd, 0x05, 0xb9, 0x0b, 0xe1, 0x11,
	0x15, 0xa1, 0x61, 0xb5, 0xfa, 0xfc, 0xd6, 0xd7, 0x87, 0xf2, 0xdc, 0xb9, 0xa3, 0xdf, 0xc0, 0xba,
	0xaa, 0xe8, 0x20, 0xec, 0xba, 0x84, 0x55, 0x52, 0xdb, 0x99, 0x9d, 0x3c, 0x5e, 0x93, 0xc6, 0x8e,
	0xb0, 0xa1, 0x07, 0x80, 0x12, 0x69, 0x46, 0x91, 0x69, 0x11, 0x59, 0x4e, 0x78, 0x64, 0x78, 0x8d,
	0x40, 0x21, 0x21, 0x2c, 0xda, 0x02, 0x8d, 0x8c, 0x0c, 0x93, 0xc9, 0x5d, 0xb6, 0x56, 0xb0, 0x5c,
	0xa2, 0x0a, 0xe4, 0x7c, 0x4a, 0x7a, 0xf6, 0x48, 0x6e, 0xb5, 0xb5, 0x82, 0xd5, 0x9a, 0x23, 0x28,
	0xe9, 0x93, 0x91, 0xc8, 0x5c, 0x20, 0xc4, 0xb2, 0xb1, 0x06, 0x20, 0x7a, 0xa6, 0xce, 0xc6, 0x3e,
	0xa9, 0xfd, 0x90, 0x82, 0xf5, 0xa9, 0x77, 0x0a, 0xb5, 0x21, 0xeb, 0x1a, 0x43, 0x79, 0x69, 0x8b,
	0xbb, 0x4f, 0xaf, 0xfc, 0xc0, 0xd5, 0x3b, 0xf6, 0xd0, 0x77, 0xc8, 0x51, 0x43, 0x3e, 0xa1, 0xad,
	0x15, 0x2c, 0x78, 0x50, 0x3d, 0x7e, 0x93, 0xd2, 0x97, 0xbf, 0x49, 0x7c, 0xdf, 0x32, 0xaa, 0xf6,
	0x02, 0x8a, 0xd3, 0x4c, 0x68, 0x03, 0x0a, 0xf8, 0xe4, 0x9f, 0xed, 0x03, 0x1d, 0x9f, 0x34, 0x5e,
	0xb5, 0x4b, 0x2b, 0xa8, 0x08, 0x70, 0x74, 0xb8, 0xdf, 0x39, 0xd3, 0x9b, 0x27, 0xed, 0x76, 0x29,
	0x85, 0x00, 0x72, 0x78, 0xbf, 0x7d, 0x70, 0x72, 0x5c, 0x4a, 0x37, 0x0a, 0x90, 0x77, 0xba, 0xba,
	0x2f, 0x90, 0xb5, 0x6f, 0xd2, 0x50, 0x48, 0xb4, 0x67, 0x64, 0x41, 0x31, 0x10, 0xdc, 0x71, 0x7f,
	0x4f, 0x89, 0x3d, 0x3d, 0xbf, 0x62, 0x7f, 0x57, 0x39, 0xaa, 0x55, 0x9c, 0xe8, 0x7a, 0x90, 0x34,
	0x2f, 0x9b, 0x71, 0xd5, 0x87, 0xeb, 0x1f, 0xe1, 0x45, 0x77, 0x61, 0x43, 0xed, 0x52, 0x0f, 0x88,
	0xe9, 0xb9, 0x56, 0x20, 0x76, 0x9b, 0xc2, 0x45, 0x65, 0xee, 0x48, 0x2b, 0x7a, 0x04, 0x9b, 0xde,
	0x39, 0xa1, 0xd4, 0xb6, 0x88, 0xea, 0x3a, 0xba, 0x38, 0x41, 0x59, 0xbc, 0x28, 0xf2, 0xc9, 0x2b,
	0xdf, 0x36, 0x86, 0xa4, 0x51, 0x82, 0x88, 0x23, 0x52, 0xea, 0xcb, 0x34, 0xe4, 0xe3, 0x57, 0x07,
	0xfd, 0x17, 0xd6, 0x94, 0x4e, 0xfc, 0xd1, 0x1a, 0x2b, 0x95, 0x9e, 0x5c, 0xe9, 0xc9, 0x52, 0x1a,
	0x89, 0xdf, 0xb1, 0x42, 0x85, 0x60, 0x62, 0x5c, 0x5a, 0x1f, 0x03, 0xca, 0x73, 0x9c, 0xa8, 0x0a,
	0xab, 0x06, 0x63, 0x64, 0xe8, 0x33, 0x29, 0x8b, 0x86, 0xe3, 0xf5, 0x67, 0x08, 0x52, 0x84, 0x35,
	0x91, 0x69, 0x24, 0xc7, 0xd7, 0x1a, 0x14, 0xa7, 0x67, 0x2d, 0x64, 0x41, 0x5e, 0x69, 0x62, 0x76,
	0x95, 0x20, 0x87, 0x57, 0x1f, 0xd5, 0x94, 0x2a, 0xd3, 0xc6, 0x58, 0x9e, 0x55, 0xc9, 0xdc, 0xec,
	0x2e, 0xad, 0xcd, 0x8f, 0x19, 0xa8, 0x5e, 0x4e, 0xcd, 0x6b, 0x68, 0x68, 0x8c, 0x74, 0xd3, 0x73,
	0x5d, 0xf9, 0x62, 0x47, 0x62, 0x15, 0x87, 0xc6, 0xa8, 0x39, 0xb1, 0xa2, 0x3f, 0xc1, 0x2d, 0xf1,
	0x6a, 0xf1, 0x68, 0x9f, 0xb8, 0x96, 0xed, 0xf6, 0xf9, 0xd0, 0x12, 0x92, 0x80, 0x05, 0x6a, 0x62,
	0xdb, 0xe2, 0x01, 0xc7, 0xc6, 0xe8, 0x54, 0xba, 0xb1, 0xf2, 0xa2, 0x7b, 0x50, 0x8e, 0xa1, 0x31,
	0x44, 0xb6, 0xdb, 0x0d, 0x05, 0x89, 0x63, 0x1f, 0xc1, 0x66, 0xe0, 0x10, 0xe2, 0xeb, 0x17, 0xb6,
	0x6b, 0x79, 0x17, 0x71, 0x61, 0x67, 0x45, 0x61, 0x23, 0xe1, 0x7b, 0x23, 0x5c, 0x51, 0x71, 0xef,
	0xc1, 0x4d, 0xc1, 0x6e, 0x7a, 0x6e, 0x40, 0xcc, 0x90, 0xd9, 0xe7, 0x44, 0x27, 0x94, 0x7a, 0xe2,
	0x65, 0xe5, 0xdf, 0xb8, 0xc1, 0xdd, 0xcd, 0x89, 0xf7, 0x50, 0x38, 0xd1, 0x21, 0xfc, 0x4a, 0xe0,
	0x2c, 0xc2, 0x64, 0x8e, 0xba, 0xed, 0x32, 0x42, 0xcf, 0x0d, 0x27, 0xfe, 0x68, 0x4e, 0x7c, 0xf4,
	0x36, 0x0f, 0x3b, 0x88, 0xa2, 0x5e, 0xa9, 0xa0, 0xe8, 0xf3, 0x2f, 0x61, 0x7b, 0x2e, 0x39, 0xdd,
	0x27, 0x34, 0x21, 0xa9, 0x98, 0xc2, 0x34, 0xc9, 0x93, 0xc8, 0xf5, 0x94, 0xd0, 0x89, 0xc0, 0x53,
	0xfa, 0x12, 0x35, 0x3d, 0x71, 0x1e, 0x93, 0xb8, 0x72, 0xf2, 0x9a, 0xe8, 0x7b, 0xa8, 0xdc, 0xa7,
	0xd2, 0xcb, 0x3b, 0x9a, 0x19, 0x77, 0xb4, 0x0f, 0x59, 0x40, 0xf3, 0x23, 0x1d, 0xfa, 0x3b, 0x68,
	0x16, 0x71, 0x8c, 0xe8, 0xa6, 0x3e, 0x5e, 0x6e, 0x22, 0xac, 0x1f, 0x70, 0x2c, 0x96, 0x14, 0x9c,
	0xcb, 0xe8, 0x7a, 0x94, 0xa9, 0x0a, 0x5c, 0x96, 0x6b, 0x9f, 0x63, 0xb1, 0xa4, 0xa8, 0x7e, 0x9f,
	0x02, 0x4d, 0x90, 0xa3, 0x0a, 0x5c, 0x8b, 0xd2, 0xe5, 0x7b, 0x4c, 0xe3, 0x68, 0x89, 0x1e, 0xc1,
	0xf5, 0x9e, 0x3d, 0x22, 0x96, 0x2e, 0x3e, 0x1f, 0x9f, 0x0e, 0xff, 0x7a, 0xaa, 0xb5, 0x82, 0xcb,
	0xc2, 0x29, 0x48, 0xa2, 0x43, 0xf9, 0x33, 0xdc, 0x22, 0x23, 0xdf, 0x73, 0x89, 0xcb, 0x6c, 0xc3,
	0x99, 0xc1, 0x65, 0x14, 0xee, 0x66, 0x22, 0x64, 0x0a, 0x7d, 0x59, 0x77, 0xc8, 0x5e, 0xda, 0x1d,
	0xca, 0xb0, 0xa1, 0x6a, 0x89, 0x7f, 0x88, 0xbf, 0x9b, 0xd5, 0x6f, 0x53, 0xa0, 0x89, 0x4c, 0x17,
	0x24, 0xf6, 0x6b, 0x28, 0xf4, 0xa9, 0x6f, 0xea, 0x01, 0x33, 0x58, 0x18, 0xc4, 0x0f, 0x34, 0x70,
	0x63, 0x47, 0xd8, 0x78, 0x08, 0x67, 0xde, 0x95, 0x25, 0x1d, 0x3f, 0xd5, 0x62, 0xc6, 0xdf, 0x15,
	0x95, 0x1c, 0x85, 0x44, 0x2c, 0x7c, 0x97, 0x5a, 0x14, 0xa2, 0x58, 0x2e, 0xcb, 0x48, 0xbb, 0x34,
	0xa3, 0x35, 0x00, 0xf1, 0x45, 0x39, 0x04, 0xfc, 0x94, 0x85, 0xd2, 0xec, 0x68, 0x8f, 0x5e, 0xc3,
	0x2a, 0x1b, 0x50, 0x8f, 0x31, 0x87, 0xa8, 0xaa, 0xfa, 0xe3, 0x32, 0x7f, 0x0d, 0xea, 0x67, 0x0a,
	0x8c, 0x63, 0x1a, 0x74, 0x06, 0x79, 0x46, 0xe8, 0x90, 0x0f, 0x3a, 0xd1, 0x64, 0xb9, 0xb7, 0x1c,
	0x67, 0x84, 0xc6, 0x13, 0xa2, 0xea, 0x87, 0x34, 0xac, 0x46, 0x1f, 0x5b, 0x58, 0x66, 0x9b, 0x96,
	0x77, 0xe1, 0x06, 0x8c, 0x12, 0x63, 0xa8, 0x3b, 0xf6, 0x90, 0xff, 0xf3, 0xf6, 0xe5, 0xb1, 0x64,
	0x30, 0x9a, 0xf8, 0x8e, 0xb8, 0xab, 0xe1, 0x07, 0xe8, 0x3e, 0xa0, 0xd0, 0x9f, 0x8b, 0xcf, 0x88,
	0xf8, 0x52, 0xe4, 0x89, 0xa3, 0xf7, 0x60, 0x2b, 0x4a, 0x54, 0x37, 0x7a, 0x8c, 0xd0, 0xe9, 0xe6,
	0xd6, 0x5a, 0xc1, 0x9b, 0x91, 0x7f, 0x9f, 0xbb, 0xa3, 0x72, 0xdc, 0x85, 0xcd, 0x19, 0x5c, 0x77,
	0xcc, 0x88, 0xec, 0x6e, 0x1c, 0x85, 0xa6, 0x50, 0x0d, 0xee, 0x43, 0xed, 0x04, 0xa6, 0xe7, 0xd1,
	0xa9, 0x8e, 0x56, 0xd8, 0xbd, 0x3d, 0xf7, 0x66, 0x1c, 0x78, 0x61, 0xd7, 0x21, 0xff, 0xe2, 0x53,
	0xec, 0x84, 0xef, 0xa5, 0x17, 0xed, 0x41, 0xcc, 0x03, 0x53, 0x7b, 0xa8, 0xfe, 0x0f, 0xf2, 0xb1,
	0xd8, 0x0b, 0x44, 0xdd, 0x83, 0x9b, 0xf1, 0x41, 0xcc, 0x64, 0x2d, 0xee, 0x2f, 0xbe, 0x11, 0xbb,
	0x93, 0x49, 0x37, 0x56, 0xff, 0x9d, 0x93, 0x67, 0xdc, 0xcd, 0x89, 0x4d, 0xfe, 0xe1, 0xe7, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xed, 0xa1, 0xb3, 0x65, 0x5c, 0x12, 0x00, 0x00,
}
