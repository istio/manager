// Code generated by protoc-gen-go.
// source: cfg.proto
// DO NOT EDIT!

/*
Package config is a generated protocol buffer package.

It is generated from these files:
	cfg.proto

It has these top-level messages:
	ProxyConfig
	RouteRule
	L4RouteRule
	HttpRouteRule
	L4MatchCondition
	L4MatchAttributes
	ClusterIdentifier
	WeightedCluster
	HttpMatchCondition
	StringMatch
	UpstreamCluster
	LoadBalancingPolicy
	TimeoutPolicy
	RetryPolicy
	CircuitBreakerPolicy
	HttpFaultInjection
	L4FaultInjection
*/
package config

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"
import google_protobuf1 "github.com/golang/protobuf/ptypes/wrappers"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// protocol Tcp|Udp
type L4MatchAttributes_L4Protocol int32

const (
	L4MatchAttributes_TCP L4MatchAttributes_L4Protocol = 0
	L4MatchAttributes_UDP L4MatchAttributes_L4Protocol = 1
)

var L4MatchAttributes_L4Protocol_name = map[int32]string{
	0: "TCP",
	1: "UDP",
}
var L4MatchAttributes_L4Protocol_value = map[string]int32{
	"TCP": 0,
	"UDP": 1,
}

func (x L4MatchAttributes_L4Protocol) String() string {
	return proto.EnumName(L4MatchAttributes_L4Protocol_name, int32(x))
}
func (L4MatchAttributes_L4Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0}
}

type LoadBalancingPolicy_SimpleLBPolicy int32

const (
	// These four simple load balancing policies have literally no
	// additional configuration.
	LoadBalancingPolicy_ROUND_ROBIN LoadBalancingPolicy_SimpleLBPolicy = 0
	LoadBalancingPolicy_LEAST_CONN  LoadBalancingPolicy_SimpleLBPolicy = 1
	LoadBalancingPolicy_IP_HASH     LoadBalancingPolicy_SimpleLBPolicy = 2
	LoadBalancingPolicy_RANDOM      LoadBalancingPolicy_SimpleLBPolicy = 3
)

var LoadBalancingPolicy_SimpleLBPolicy_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_CONN",
	2: "IP_HASH",
	3: "RANDOM",
}
var LoadBalancingPolicy_SimpleLBPolicy_value = map[string]int32{
	"ROUND_ROBIN": 0,
	"LEAST_CONN":  1,
	"IP_HASH":     2,
	"RANDOM":      3,
}

func (x LoadBalancingPolicy_SimpleLBPolicy) String() string {
	return proto.EnumName(LoadBalancingPolicy_SimpleLBPolicy_name, int32(x))
}
func (LoadBalancingPolicy_SimpleLBPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 0}
}

// Proxy level global configurations go here
type ProxyConfig struct {
	// config specification version.
	Revision int32 `protobuf:"varint,1,opt,name=revision" json:"revision,omitempty"`
	// Since a Http request can match multiple route rules (e.g., there are
	// two routes for the prefix /foo, with differing Http match attributes
	// such as Http headers), the first rule to match will/should be chosen
	// by proxy implementations N.B.: When a request does not match any rule
	// for Http, the downstream service would receive a HTTP 404.
	RouteRules []*RouteRule `protobuf:"bytes,2,rep,name=route_rules,json=routeRules" json:"route_rules,omitempty"`
	// RouteRule determines the upstream cluster to which traffic should be
	// routed to.  The UpstreamCluster describes how to obtain cluster
	// members (through discovery or through static configuration), and
	// policies that determine how to handle traffic (load balancing
	// policies, failure recovery policies such as timeouts, retries, circuit
	// breakers), etc.
	UpstreamClusters []*UpstreamCluster `protobuf:"bytes,3,rep,name=upstream_clusters,json=upstreamClusters" json:"upstream_clusters,omitempty"`
}

func (m *ProxyConfig) Reset()                    { *m = ProxyConfig{} }
func (m *ProxyConfig) String() string            { return proto.CompactTextString(m) }
func (*ProxyConfig) ProtoMessage()               {}
func (*ProxyConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ProxyConfig) GetRevision() int32 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *ProxyConfig) GetRouteRules() []*RouteRule {
	if m != nil {
		return m.RouteRules
	}
	return nil
}

func (m *ProxyConfig) GetUpstreamClusters() []*UpstreamCluster {
	if m != nil {
		return m.UpstreamClusters
	}
	return nil
}

// Describes rules for routing a request/connection to an upstream
// service, based on attributes associated with the request/connection
// and downstream service invoking the API call. The choice of the specific
// upstream cluster will be determined by the routing rule.
type RouteRule struct {
	// Uniquely identifies the upstream service (not its versions) associated
	// with this RouteRule. This is applicable for both Http and Tcp.
	// Note: The name used here must match with the 'name' field in the
	// ClusterIdentifier, that is used to uniquely identify a version of the
	// upstream service.
	Destination string `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	// Types that are valid to be assigned to RouteRule:
	//	*RouteRule_Layer4
	//	*RouteRule_Http
	RouteRule isRouteRule_RouteRule `protobuf_oneof:"route_rule"`
}

func (m *RouteRule) Reset()                    { *m = RouteRule{} }
func (m *RouteRule) String() string            { return proto.CompactTextString(m) }
func (*RouteRule) ProtoMessage()               {}
func (*RouteRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isRouteRule_RouteRule interface {
	isRouteRule_RouteRule()
}

type RouteRule_Layer4 struct {
	Layer4 *L4RouteRule `protobuf:"bytes,2,opt,name=layer4,oneof"`
}
type RouteRule_Http struct {
	Http *HttpRouteRule `protobuf:"bytes,3,opt,name=http,oneof"`
}

func (*RouteRule_Layer4) isRouteRule_RouteRule() {}
func (*RouteRule_Http) isRouteRule_RouteRule()   {}

func (m *RouteRule) GetRouteRule() isRouteRule_RouteRule {
	if m != nil {
		return m.RouteRule
	}
	return nil
}

func (m *RouteRule) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *RouteRule) GetLayer4() *L4RouteRule {
	if x, ok := m.GetRouteRule().(*RouteRule_Layer4); ok {
		return x.Layer4
	}
	return nil
}

func (m *RouteRule) GetHttp() *HttpRouteRule {
	if x, ok := m.GetRouteRule().(*RouteRule_Http); ok {
		return x.Http
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteRule) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteRule_OneofMarshaler, _RouteRule_OneofUnmarshaler, _RouteRule_OneofSizer, []interface{}{
		(*RouteRule_Layer4)(nil),
		(*RouteRule_Http)(nil),
	}
}

func _RouteRule_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteRule)
	// route_rule
	switch x := m.RouteRule.(type) {
	case *RouteRule_Layer4:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Layer4); err != nil {
			return err
		}
	case *RouteRule_Http:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RouteRule.RouteRule has unexpected type %T", x)
	}
	return nil
}

func _RouteRule_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteRule)
	switch tag {
	case 2: // route_rule.layer4
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L4RouteRule)
		err := b.DecodeMessage(msg)
		m.RouteRule = &RouteRule_Layer4{msg}
		return true, err
	case 3: // route_rule.http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpRouteRule)
		err := b.DecodeMessage(msg)
		m.RouteRule = &RouteRule_Http{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RouteRule_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteRule)
	// route_rule
	switch x := m.RouteRule.(type) {
	case *RouteRule_Layer4:
		s := proto.Size(x.Layer4)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RouteRule_Http:
		s := proto.Size(x.Http)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Routes incoming Tcp/Udp traffic to one of the clusters of a service
// based on match criterion.
type L4RouteRule struct {
	// Set of conditions that must be satisfied, such as downstream cluster
	// labels, connection attributes, etc.
	Match *L4MatchCondition `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	// Each routing rule is associated with one or more upstream clusters,
	// (see glossary in beginning of document). Weights associated with the
	// cluster determine the proportion of traffic it receives.
	WeightedClusters []*WeightedCluster `protobuf:"bytes,2,rep,name=weighted_clusters,json=weightedClusters" json:"weighted_clusters,omitempty"`
	// TODO: This should be done on per-cluster basis.
	Fault *L4FaultInjection `protobuf:"bytes,3,opt,name=fault" json:"fault,omitempty"`
}

func (m *L4RouteRule) Reset()                    { *m = L4RouteRule{} }
func (m *L4RouteRule) String() string            { return proto.CompactTextString(m) }
func (*L4RouteRule) ProtoMessage()               {}
func (*L4RouteRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *L4RouteRule) GetMatch() *L4MatchCondition {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *L4RouteRule) GetWeightedClusters() []*WeightedCluster {
	if m != nil {
		return m.WeightedClusters
	}
	return nil
}

func (m *L4RouteRule) GetFault() *L4FaultInjection {
	if m != nil {
		return m.Fault
	}
	return nil
}

// Routes Http requests to one of the upstream clusters based on
// match criterion.
type HttpRouteRule struct {
	// Set of conditions that must be satisfied, such as downstream service
	// labels, request attributes, etc.
	Match *HttpMatchCondition `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	// Each routing rule is associated with one or more upstream clusters,
	// (see glossary in beginning of document). Weights associated with the
	// cluster determine the proportion of traffic it receives.
	WeightedClusters []*WeightedCluster `protobuf:"bytes,2,rep,name=weighted_clusters,json=weightedClusters" json:"weighted_clusters,omitempty"`
	// Faults can be injected into the API calls by the proxy, for
	// testing the failure recovery capabilities of downstream services.
	// Faults include aborting the Http request from downstream service,
	// delaying the proxying of request to the upstream service, or both.
	// TODO: This should move into UpstreamCluster
	Fault *HttpFaultInjection `protobuf:"bytes,3,opt,name=fault" json:"fault,omitempty"`
	// Custom properties per rule (depends on proxy), such as open tracing,
	// access log formats, etc. Some of these will be defined in future
	// iterations.
	CustomImpl *google_protobuf.Any `protobuf:"bytes,4,opt,name=custom_impl,json=customImpl" json:"custom_impl,omitempty"`
}

func (m *HttpRouteRule) Reset()                    { *m = HttpRouteRule{} }
func (m *HttpRouteRule) String() string            { return proto.CompactTextString(m) }
func (*HttpRouteRule) ProtoMessage()               {}
func (*HttpRouteRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *HttpRouteRule) GetMatch() *HttpMatchCondition {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *HttpRouteRule) GetWeightedClusters() []*WeightedCluster {
	if m != nil {
		return m.WeightedClusters
	}
	return nil
}

func (m *HttpRouteRule) GetFault() *HttpFaultInjection {
	if m != nil {
		return m.Fault
	}
	return nil
}

func (m *HttpRouteRule) GetCustomImpl() *google_protobuf.Any {
	if m != nil {
		return m.CustomImpl
	}
	return nil
}

// Basic routing rule match criterion using Tcp attributes and downstream
// cluster identifier
type L4MatchCondition struct {
	// Set of layer 4 match attributes such as src ip/port, dst ip/port and
	// protocol
	L4Attributes *L4MatchAttributes `protobuf:"bytes,1,opt,name=l4attributes" json:"l4attributes,omitempty"`
	// Identify the downstream cluster initiating the connection.
	SrcCluster *ClusterIdentifier `protobuf:"bytes,2,opt,name=src_cluster,json=srcCluster" json:"src_cluster,omitempty"`
}

func (m *L4MatchCondition) Reset()                    { *m = L4MatchCondition{} }
func (m *L4MatchCondition) String() string            { return proto.CompactTextString(m) }
func (*L4MatchCondition) ProtoMessage()               {}
func (*L4MatchCondition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *L4MatchCondition) GetL4Attributes() *L4MatchAttributes {
	if m != nil {
		return m.L4Attributes
	}
	return nil
}

func (m *L4MatchCondition) GetSrcCluster() *ClusterIdentifier {
	if m != nil {
		return m.SrcCluster
	}
	return nil
}

// L4 connection match attributes
type L4MatchAttributes struct {
	// IPv4 or IPv6 ip address with optional subnet. E.g., a.b.c.d/xx form or
	// just a.b.c.d
	SrcIpSubnet []string `protobuf:"bytes,1,rep,name=src_ip_subnet,json=srcIpSubnet" json:"src_ip_subnet,omitempty"`
	// source port
	SrcPort *google_protobuf1.UInt32Value `protobuf:"bytes,2,opt,name=src_port,json=srcPort" json:"src_port,omitempty"`
	// IPv4 or IPv6 ip address with optional subnet. E.g., a.b.c.d/xx form or
	// just a.b.c.d
	DstIpSubnet []string `protobuf:"bytes,3,rep,name=dst_ip_subnet,json=dstIpSubnet" json:"dst_ip_subnet,omitempty"`
	// destination port
	DstPort  *google_protobuf1.UInt32Value `protobuf:"bytes,4,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	Protocol L4MatchAttributes_L4Protocol  `protobuf:"varint,5,opt,name=protocol,enum=istio.proxy.v1alpha.config.L4MatchAttributes_L4Protocol" json:"protocol,omitempty"`
}

func (m *L4MatchAttributes) Reset()                    { *m = L4MatchAttributes{} }
func (m *L4MatchAttributes) String() string            { return proto.CompactTextString(m) }
func (*L4MatchAttributes) ProtoMessage()               {}
func (*L4MatchAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *L4MatchAttributes) GetSrcIpSubnet() []string {
	if m != nil {
		return m.SrcIpSubnet
	}
	return nil
}

func (m *L4MatchAttributes) GetSrcPort() *google_protobuf1.UInt32Value {
	if m != nil {
		return m.SrcPort
	}
	return nil
}

func (m *L4MatchAttributes) GetDstIpSubnet() []string {
	if m != nil {
		return m.DstIpSubnet
	}
	return nil
}

func (m *L4MatchAttributes) GetDstPort() *google_protobuf1.UInt32Value {
	if m != nil {
		return m.DstPort
	}
	return nil
}

func (m *L4MatchAttributes) GetProtocol() L4MatchAttributes_L4Protocol {
	if m != nil {
		return m.Protocol
	}
	return L4MatchAttributes_TCP
}

// A name and one or more tags uniquely identify an upstream or downstream
// cluster. Names and tags can be arbitrary strings, and their
// interpretation is specific to the underlying platform (e.g., in
// kubernetes, name field could correspond to the service Name, while each
// tag string could be parsed into a pod label (key:value))
type ClusterIdentifier struct {
	// Note: When used in the context of upstream clusters, the value of the
	// name field used here must match with the 'destination' field in
	// the RouteRule, that is used to assign the RouteRule to a particular
	// service
	Name string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Tags []string `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
}

func (m *ClusterIdentifier) Reset()                    { *m = ClusterIdentifier{} }
func (m *ClusterIdentifier) String() string            { return proto.CompactTextString(m) }
func (*ClusterIdentifier) ProtoMessage()               {}
func (*ClusterIdentifier) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ClusterIdentifier) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterIdentifier) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// Each routing rule is associated with one or more upstream clusters,
// (see glossary in beginning of document). Weights associated with the
// cluster determine the proportion of traffic it receives.
type WeightedCluster struct {
	// Unique identity of the upstream cluster. Must be the same as those used
	// in the definition of the UpstreamClusterPolicy.
	DstCluster *ClusterIdentifier `protobuf:"bytes,1,opt,name=dst_cluster,json=dstCluster" json:"dst_cluster,omitempty"`
	// The proportion of connections to be forwarded to the upstream
	// cluster. Max is 100. Sum of weights across versions should add up to
	// 100.
	Weight uint32 `protobuf:"varint,2,opt,name=weight" json:"weight,omitempty"`
}

func (m *WeightedCluster) Reset()                    { *m = WeightedCluster{} }
func (m *WeightedCluster) String() string            { return proto.CompactTextString(m) }
func (*WeightedCluster) ProtoMessage()               {}
func (*WeightedCluster) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *WeightedCluster) GetDstCluster() *ClusterIdentifier {
	if m != nil {
		return m.DstCluster
	}
	return nil
}

func (m *WeightedCluster) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// Http/1.1|Http/2|gRPC routing rule match criterion built on top of BaseMatchCondition
type HttpMatchCondition struct {
	// Set of layer 4 match attributes such as src ip/port, dst ip/port and
	// protocol
	L4Attributes *L4MatchAttributes `protobuf:"bytes,1,opt,name=l4attributes" json:"l4attributes,omitempty"`
	// Identify the downstream cluster initiating the connection.
	SrcCluster *ClusterIdentifier `protobuf:"bytes,2,opt,name=src_cluster,json=srcCluster" json:"src_cluster,omitempty"`
	// Set of Http request level match attributes
	Scheme string `protobuf:"bytes,3,opt,name=scheme" json:"scheme,omitempty"`
	// Match based on authority
	Authority *StringMatch `protobuf:"bytes,4,opt,name=authority" json:"authority,omitempty"`
	// Match based on URI
	Uri *StringMatch `protobuf:"bytes,5,opt,name=uri" json:"uri,omitempty"`
	// Match Http requests based on the specified headers
	// Support exact/prefix/regex match on header values
	Headers map[string]*StringMatch `protobuf:"bytes,6,rep,name=headers" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HttpMatchCondition) Reset()                    { *m = HttpMatchCondition{} }
func (m *HttpMatchCondition) String() string            { return proto.CompactTextString(m) }
func (*HttpMatchCondition) ProtoMessage()               {}
func (*HttpMatchCondition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *HttpMatchCondition) GetL4Attributes() *L4MatchAttributes {
	if m != nil {
		return m.L4Attributes
	}
	return nil
}

func (m *HttpMatchCondition) GetSrcCluster() *ClusterIdentifier {
	if m != nil {
		return m.SrcCluster
	}
	return nil
}

func (m *HttpMatchCondition) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *HttpMatchCondition) GetAuthority() *StringMatch {
	if m != nil {
		return m.Authority
	}
	return nil
}

func (m *HttpMatchCondition) GetUri() *StringMatch {
	if m != nil {
		return m.Uri
	}
	return nil
}

func (m *HttpMatchCondition) GetHeaders() map[string]*StringMatch {
	if m != nil {
		return m.Headers
	}
	return nil
}

// Describes how to matches a given string (exact match, prefix-based match
// or posix style regex based match).
type StringMatch struct {
	// Types that are valid to be assigned to MatchType:
	//	*StringMatch_Exact
	//	*StringMatch_Prefix
	//	*StringMatch_Regex
	MatchType isStringMatch_MatchType `protobuf_oneof:"match_type"`
}

func (m *StringMatch) Reset()                    { *m = StringMatch{} }
func (m *StringMatch) String() string            { return proto.CompactTextString(m) }
func (*StringMatch) ProtoMessage()               {}
func (*StringMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isStringMatch_MatchType interface {
	isStringMatch_MatchType()
}

type StringMatch_Exact struct {
	Exact string `protobuf:"bytes,1,opt,name=exact,oneof"`
}
type StringMatch_Prefix struct {
	Prefix string `protobuf:"bytes,2,opt,name=prefix,oneof"`
}
type StringMatch_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,oneof"`
}

func (*StringMatch_Exact) isStringMatch_MatchType()  {}
func (*StringMatch_Prefix) isStringMatch_MatchType() {}
func (*StringMatch_Regex) isStringMatch_MatchType()  {}

func (m *StringMatch) GetMatchType() isStringMatch_MatchType {
	if m != nil {
		return m.MatchType
	}
	return nil
}

func (m *StringMatch) GetExact() string {
	if x, ok := m.GetMatchType().(*StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *StringMatch) GetPrefix() string {
	if x, ok := m.GetMatchType().(*StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *StringMatch) GetRegex() string {
	if x, ok := m.GetMatchType().(*StringMatch_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StringMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StringMatch_OneofMarshaler, _StringMatch_OneofUnmarshaler, _StringMatch_OneofSizer, []interface{}{
		(*StringMatch_Exact)(nil),
		(*StringMatch_Prefix)(nil),
		(*StringMatch_Regex)(nil),
	}
}

func _StringMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Exact)
	case *StringMatch_Prefix:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Prefix)
	case *StringMatch_Regex:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Regex)
	case nil:
	default:
		return fmt.Errorf("StringMatch.MatchType has unexpected type %T", x)
	}
	return nil
}

func _StringMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StringMatch)
	switch tag {
	case 1: // match_type.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Exact{x}
		return true, err
	case 2: // match_type.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Prefix{x}
		return true, err
	case 3: // match_type.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MatchType = &StringMatch_Regex{x}
		return true, err
	default:
		return false, nil
	}
}

func _StringMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StringMatch)
	// match_type
	switch x := m.MatchType.(type) {
	case *StringMatch_Exact:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *StringMatch_Prefix:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case *StringMatch_Regex:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// N.B. The policies are enforced on egress connections or requests,
// i.e., enforced when the downstream service (caller) is opening a
// connection/sending a request via the proxy to the upstream service.
type UpstreamCluster struct {
	// Unique identifier of the upstream cluster. The name and tags in the
	// cluster identifier are used by the service discovery component of the
	// proxy to identify the IP addresses of the pods|VMs running this
	// service.
	// TODO: Need to have a way to statically specify the hosts/IPs.
	Cluster *ClusterIdentifier `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Should be either http://.. or tcp://..
	HealthCheckEndpoint string                `protobuf:"bytes,2,opt,name=health_check_endpoint,json=healthCheckEndpoint" json:"health_check_endpoint,omitempty"`
	LbPolicy            *LoadBalancingPolicy  `protobuf:"bytes,3,opt,name=lb_policy,json=lbPolicy" json:"lb_policy,omitempty"`
	Timeout             *TimeoutPolicy        `protobuf:"bytes,4,opt,name=timeout" json:"timeout,omitempty"`
	Retry               *RetryPolicy          `protobuf:"bytes,5,opt,name=retry" json:"retry,omitempty"`
	CircuitBreaker      *CircuitBreakerPolicy `protobuf:"bytes,6,opt,name=circuit_breaker,json=circuitBreaker" json:"circuit_breaker,omitempty"`
}

func (m *UpstreamCluster) Reset()                    { *m = UpstreamCluster{} }
func (m *UpstreamCluster) String() string            { return proto.CompactTextString(m) }
func (*UpstreamCluster) ProtoMessage()               {}
func (*UpstreamCluster) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *UpstreamCluster) GetCluster() *ClusterIdentifier {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *UpstreamCluster) GetHealthCheckEndpoint() string {
	if m != nil {
		return m.HealthCheckEndpoint
	}
	return ""
}

func (m *UpstreamCluster) GetLbPolicy() *LoadBalancingPolicy {
	if m != nil {
		return m.LbPolicy
	}
	return nil
}

func (m *UpstreamCluster) GetTimeout() *TimeoutPolicy {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *UpstreamCluster) GetRetry() *RetryPolicy {
	if m != nil {
		return m.Retry
	}
	return nil
}

func (m *UpstreamCluster) GetCircuitBreaker() *CircuitBreakerPolicy {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

// Load balancing policy to use when forwarding traffic to upstream clusters.
type LoadBalancingPolicy struct {
	// Types that are valid to be assigned to LbPolicy:
	//	*LoadBalancingPolicy_Name
	//	*LoadBalancingPolicy_CustomImpl
	LbPolicy isLoadBalancingPolicy_LbPolicy `protobuf_oneof:"lb_policy"`
}

func (m *LoadBalancingPolicy) Reset()                    { *m = LoadBalancingPolicy{} }
func (m *LoadBalancingPolicy) String() string            { return proto.CompactTextString(m) }
func (*LoadBalancingPolicy) ProtoMessage()               {}
func (*LoadBalancingPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isLoadBalancingPolicy_LbPolicy interface {
	isLoadBalancingPolicy_LbPolicy()
}

type LoadBalancingPolicy_Name struct {
	Name LoadBalancingPolicy_SimpleLBPolicy `protobuf:"varint,1,opt,name=name,enum=istio.proxy.v1alpha.config.LoadBalancingPolicy_SimpleLBPolicy,oneof"`
}
type LoadBalancingPolicy_CustomImpl struct {
	CustomImpl *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom_impl,json=customImpl,oneof"`
}

func (*LoadBalancingPolicy_Name) isLoadBalancingPolicy_LbPolicy()       {}
func (*LoadBalancingPolicy_CustomImpl) isLoadBalancingPolicy_LbPolicy() {}

func (m *LoadBalancingPolicy) GetLbPolicy() isLoadBalancingPolicy_LbPolicy {
	if m != nil {
		return m.LbPolicy
	}
	return nil
}

func (m *LoadBalancingPolicy) GetName() LoadBalancingPolicy_SimpleLBPolicy {
	if x, ok := m.GetLbPolicy().(*LoadBalancingPolicy_Name); ok {
		return x.Name
	}
	return LoadBalancingPolicy_ROUND_ROBIN
}

func (m *LoadBalancingPolicy) GetCustomImpl() *google_protobuf.Any {
	if x, ok := m.GetLbPolicy().(*LoadBalancingPolicy_CustomImpl); ok {
		return x.CustomImpl
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LoadBalancingPolicy) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LoadBalancingPolicy_OneofMarshaler, _LoadBalancingPolicy_OneofUnmarshaler, _LoadBalancingPolicy_OneofSizer, []interface{}{
		(*LoadBalancingPolicy_Name)(nil),
		(*LoadBalancingPolicy_CustomImpl)(nil),
	}
}

func _LoadBalancingPolicy_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LoadBalancingPolicy)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancingPolicy_Name:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Name))
	case *LoadBalancingPolicy_CustomImpl:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomImpl); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LoadBalancingPolicy.LbPolicy has unexpected type %T", x)
	}
	return nil
}

func _LoadBalancingPolicy_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LoadBalancingPolicy)
	switch tag {
	case 1: // lb_policy.name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.LbPolicy = &LoadBalancingPolicy_Name{LoadBalancingPolicy_SimpleLBPolicy(x)}
		return true, err
	case 2: // lb_policy.custom_impl
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.LbPolicy = &LoadBalancingPolicy_CustomImpl{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LoadBalancingPolicy_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LoadBalancingPolicy)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancingPolicy_Name:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Name))
	case *LoadBalancingPolicy_CustomImpl:
		s := proto.Size(x.CustomImpl)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request timeout: wait time until a response is received. Does not
// indicate the time for the entire response to arrive.
type TimeoutPolicy struct {
	// Types that are valid to be assigned to TimeoutPolicy:
	//	*TimeoutPolicy_SimpleTimeout
	//	*TimeoutPolicy_CustomImpl
	TimeoutPolicy isTimeoutPolicy_TimeoutPolicy `protobuf_oneof:"timeout_policy"`
}

func (m *TimeoutPolicy) Reset()                    { *m = TimeoutPolicy{} }
func (m *TimeoutPolicy) String() string            { return proto.CompactTextString(m) }
func (*TimeoutPolicy) ProtoMessage()               {}
func (*TimeoutPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type isTimeoutPolicy_TimeoutPolicy interface {
	isTimeoutPolicy_TimeoutPolicy()
}

type TimeoutPolicy_SimpleTimeout struct {
	SimpleTimeout *TimeoutPolicy_SimpleTimeoutPolicy `protobuf:"bytes,1,opt,name=simple_timeout,json=simpleTimeout,oneof"`
}
type TimeoutPolicy_CustomImpl struct {
	CustomImpl *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom_impl,json=customImpl,oneof"`
}

func (*TimeoutPolicy_SimpleTimeout) isTimeoutPolicy_TimeoutPolicy() {}
func (*TimeoutPolicy_CustomImpl) isTimeoutPolicy_TimeoutPolicy()    {}

func (m *TimeoutPolicy) GetTimeoutPolicy() isTimeoutPolicy_TimeoutPolicy {
	if m != nil {
		return m.TimeoutPolicy
	}
	return nil
}

func (m *TimeoutPolicy) GetSimpleTimeout() *TimeoutPolicy_SimpleTimeoutPolicy {
	if x, ok := m.GetTimeoutPolicy().(*TimeoutPolicy_SimpleTimeout); ok {
		return x.SimpleTimeout
	}
	return nil
}

func (m *TimeoutPolicy) GetCustomImpl() *google_protobuf.Any {
	if x, ok := m.GetTimeoutPolicy().(*TimeoutPolicy_CustomImpl); ok {
		return x.CustomImpl
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TimeoutPolicy) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TimeoutPolicy_OneofMarshaler, _TimeoutPolicy_OneofUnmarshaler, _TimeoutPolicy_OneofSizer, []interface{}{
		(*TimeoutPolicy_SimpleTimeout)(nil),
		(*TimeoutPolicy_CustomImpl)(nil),
	}
}

func _TimeoutPolicy_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TimeoutPolicy)
	// timeout_policy
	switch x := m.TimeoutPolicy.(type) {
	case *TimeoutPolicy_SimpleTimeout:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleTimeout); err != nil {
			return err
		}
	case *TimeoutPolicy_CustomImpl:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomImpl); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TimeoutPolicy.TimeoutPolicy has unexpected type %T", x)
	}
	return nil
}

func _TimeoutPolicy_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TimeoutPolicy)
	switch tag {
	case 1: // timeout_policy.simple_timeout
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimeoutPolicy_SimpleTimeoutPolicy)
		err := b.DecodeMessage(msg)
		m.TimeoutPolicy = &TimeoutPolicy_SimpleTimeout{msg}
		return true, err
	case 2: // timeout_policy.custom_impl
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.TimeoutPolicy = &TimeoutPolicy_CustomImpl{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TimeoutPolicy_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TimeoutPolicy)
	// timeout_policy
	switch x := m.TimeoutPolicy.(type) {
	case *TimeoutPolicy_SimpleTimeout:
		s := proto.Size(x.SimpleTimeout)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TimeoutPolicy_CustomImpl:
		s := proto.Size(x.CustomImpl)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TimeoutPolicy_SimpleTimeoutPolicy struct {
	// timeout is per attempt, when retries are specified as well.
	// seconds.nanoseconds format
	TimeoutSeconds float64 `protobuf:"fixed64,1,opt,name=timeout_seconds,json=timeoutSeconds" json:"timeout_seconds,omitempty"`
	// Downstream service could specify timeout via Http header to the
	// proxy, if the proxy supports such a feature.
	OverrideHeaderName string `protobuf:"bytes,2,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *TimeoutPolicy_SimpleTimeoutPolicy) Reset()         { *m = TimeoutPolicy_SimpleTimeoutPolicy{} }
func (m *TimeoutPolicy_SimpleTimeoutPolicy) String() string { return proto.CompactTextString(m) }
func (*TimeoutPolicy_SimpleTimeoutPolicy) ProtoMessage()    {}
func (*TimeoutPolicy_SimpleTimeoutPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{12, 0}
}

func (m *TimeoutPolicy_SimpleTimeoutPolicy) GetTimeoutSeconds() float64 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

func (m *TimeoutPolicy_SimpleTimeoutPolicy) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// Retry policy to use when a request to the upstream cluster fails.
type RetryPolicy struct {
	// Types that are valid to be assigned to RetryPolicy:
	//	*RetryPolicy_SimpleRetry
	//	*RetryPolicy_CustomImpl
	RetryPolicy isRetryPolicy_RetryPolicy `protobuf_oneof:"retry_policy"`
}

func (m *RetryPolicy) Reset()                    { *m = RetryPolicy{} }
func (m *RetryPolicy) String() string            { return proto.CompactTextString(m) }
func (*RetryPolicy) ProtoMessage()               {}
func (*RetryPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type isRetryPolicy_RetryPolicy interface {
	isRetryPolicy_RetryPolicy()
}

type RetryPolicy_SimpleRetry struct {
	SimpleRetry *RetryPolicy_SimpleRetryPolicy `protobuf:"bytes,1,opt,name=simple_retry,json=simpleRetry,oneof"`
}
type RetryPolicy_CustomImpl struct {
	CustomImpl *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom_impl,json=customImpl,oneof"`
}

func (*RetryPolicy_SimpleRetry) isRetryPolicy_RetryPolicy() {}
func (*RetryPolicy_CustomImpl) isRetryPolicy_RetryPolicy()  {}

func (m *RetryPolicy) GetRetryPolicy() isRetryPolicy_RetryPolicy {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *RetryPolicy) GetSimpleRetry() *RetryPolicy_SimpleRetryPolicy {
	if x, ok := m.GetRetryPolicy().(*RetryPolicy_SimpleRetry); ok {
		return x.SimpleRetry
	}
	return nil
}

func (m *RetryPolicy) GetCustomImpl() *google_protobuf.Any {
	if x, ok := m.GetRetryPolicy().(*RetryPolicy_CustomImpl); ok {
		return x.CustomImpl
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RetryPolicy) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RetryPolicy_OneofMarshaler, _RetryPolicy_OneofUnmarshaler, _RetryPolicy_OneofSizer, []interface{}{
		(*RetryPolicy_SimpleRetry)(nil),
		(*RetryPolicy_CustomImpl)(nil),
	}
}

func _RetryPolicy_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RetryPolicy)
	// retry_policy
	switch x := m.RetryPolicy.(type) {
	case *RetryPolicy_SimpleRetry:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleRetry); err != nil {
			return err
		}
	case *RetryPolicy_CustomImpl:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomImpl); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RetryPolicy.RetryPolicy has unexpected type %T", x)
	}
	return nil
}

func _RetryPolicy_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RetryPolicy)
	switch tag {
	case 1: // retry_policy.simple_retry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RetryPolicy_SimpleRetryPolicy)
		err := b.DecodeMessage(msg)
		m.RetryPolicy = &RetryPolicy_SimpleRetry{msg}
		return true, err
	case 2: // retry_policy.custom_impl
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.RetryPolicy = &RetryPolicy_CustomImpl{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RetryPolicy_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RetryPolicy)
	// retry_policy
	switch x := m.RetryPolicy.(type) {
	case *RetryPolicy_SimpleRetry:
		s := proto.Size(x.SimpleRetry)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RetryPolicy_CustomImpl:
		s := proto.Size(x.CustomImpl)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RetryPolicy_SimpleRetryPolicy struct {
	// number of times the request to the upstream cluster should be retried.
	// total timeout would be attempts * timeout
	Attempts uint32 `protobuf:"varint,1,opt,name=attempts" json:"attempts,omitempty"`
	// Downstream Service could specify retry attempts via Http header to
	// the proxy, if the proxy supports such a feature.
	OverrideHeaderName string `protobuf:"bytes,2,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *RetryPolicy_SimpleRetryPolicy) Reset()         { *m = RetryPolicy_SimpleRetryPolicy{} }
func (m *RetryPolicy_SimpleRetryPolicy) String() string { return proto.CompactTextString(m) }
func (*RetryPolicy_SimpleRetryPolicy) ProtoMessage()    {}
func (*RetryPolicy_SimpleRetryPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0}
}

func (m *RetryPolicy_SimpleRetryPolicy) GetAttempts() uint32 {
	if m != nil {
		return m.Attempts
	}
	return 0
}

func (m *RetryPolicy_SimpleRetryPolicy) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// A minimal circuit breaker configuration for the upstream cluster.
type CircuitBreakerPolicy struct {
	// Types that are valid to be assigned to CbPolicy:
	//	*CircuitBreakerPolicy_SimpleCb
	//	*CircuitBreakerPolicy_CustomImpl
	CbPolicy isCircuitBreakerPolicy_CbPolicy `protobuf_oneof:"cb_policy"`
}

func (m *CircuitBreakerPolicy) Reset()                    { *m = CircuitBreakerPolicy{} }
func (m *CircuitBreakerPolicy) String() string            { return proto.CompactTextString(m) }
func (*CircuitBreakerPolicy) ProtoMessage()               {}
func (*CircuitBreakerPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type isCircuitBreakerPolicy_CbPolicy interface {
	isCircuitBreakerPolicy_CbPolicy()
}

type CircuitBreakerPolicy_SimpleCb struct {
	SimpleCb *CircuitBreakerPolicy_SimpleCircuitBreakerPolicy `protobuf:"bytes,1,opt,name=simple_cb,json=simpleCb,oneof"`
}
type CircuitBreakerPolicy_CustomImpl struct {
	CustomImpl *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom_impl,json=customImpl,oneof"`
}

func (*CircuitBreakerPolicy_SimpleCb) isCircuitBreakerPolicy_CbPolicy()   {}
func (*CircuitBreakerPolicy_CustomImpl) isCircuitBreakerPolicy_CbPolicy() {}

func (m *CircuitBreakerPolicy) GetCbPolicy() isCircuitBreakerPolicy_CbPolicy {
	if m != nil {
		return m.CbPolicy
	}
	return nil
}

func (m *CircuitBreakerPolicy) GetSimpleCb() *CircuitBreakerPolicy_SimpleCircuitBreakerPolicy {
	if x, ok := m.GetCbPolicy().(*CircuitBreakerPolicy_SimpleCb); ok {
		return x.SimpleCb
	}
	return nil
}

func (m *CircuitBreakerPolicy) GetCustomImpl() *google_protobuf.Any {
	if x, ok := m.GetCbPolicy().(*CircuitBreakerPolicy_CustomImpl); ok {
		return x.CustomImpl
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CircuitBreakerPolicy) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CircuitBreakerPolicy_OneofMarshaler, _CircuitBreakerPolicy_OneofUnmarshaler, _CircuitBreakerPolicy_OneofSizer, []interface{}{
		(*CircuitBreakerPolicy_SimpleCb)(nil),
		(*CircuitBreakerPolicy_CustomImpl)(nil),
	}
}

func _CircuitBreakerPolicy_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CircuitBreakerPolicy)
	// cb_policy
	switch x := m.CbPolicy.(type) {
	case *CircuitBreakerPolicy_SimpleCb:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SimpleCb); err != nil {
			return err
		}
	case *CircuitBreakerPolicy_CustomImpl:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomImpl); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CircuitBreakerPolicy.CbPolicy has unexpected type %T", x)
	}
	return nil
}

func _CircuitBreakerPolicy_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CircuitBreakerPolicy)
	switch tag {
	case 1: // cb_policy.simple_cb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CircuitBreakerPolicy_SimpleCircuitBreakerPolicy)
		err := b.DecodeMessage(msg)
		m.CbPolicy = &CircuitBreakerPolicy_SimpleCb{msg}
		return true, err
	case 2: // cb_policy.custom_impl
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.CbPolicy = &CircuitBreakerPolicy_CustomImpl{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CircuitBreakerPolicy_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CircuitBreakerPolicy)
	// cb_policy
	switch x := m.CbPolicy.(type) {
	case *CircuitBreakerPolicy_SimpleCb:
		s := proto.Size(x.SimpleCb)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CircuitBreakerPolicy_CustomImpl:
		s := proto.Size(x.CustomImpl)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CircuitBreakerPolicy_SimpleCircuitBreakerPolicy struct {
	// (for an unhealthy upstream cluster) number of consecutive requests that
	// should succeed before the upstream cluster is marked healthy.
	SuccessThreshold uint32 `protobuf:"varint,1,opt,name=success_threshold,json=successThreshold" json:"success_threshold,omitempty"`
	// (for a healthy upstream cluster) number of consecutive requests that
	// can fail before the upstream cluster is marked unhealthy.
	FailureThreshold uint32 `protobuf:"varint,2,opt,name=failure_threshold,json=failureThreshold" json:"failure_threshold,omitempty"`
	// When a healthy upstream cluster becomes unhealthy, duration to wait before
	// attempting to send requests to that upstream cluster.
	// format seconds.nanoseconds
	ResetTimeoutSeconds float64 `protobuf:"fixed64,3,opt,name=reset_timeout_seconds,json=resetTimeoutSeconds" json:"reset_timeout_seconds,omitempty"`
}

func (m *CircuitBreakerPolicy_SimpleCircuitBreakerPolicy) Reset() {
	*m = CircuitBreakerPolicy_SimpleCircuitBreakerPolicy{}
}
func (m *CircuitBreakerPolicy_SimpleCircuitBreakerPolicy) String() string {
	return proto.CompactTextString(m)
}
func (*CircuitBreakerPolicy_SimpleCircuitBreakerPolicy) ProtoMessage() {}
func (*CircuitBreakerPolicy_SimpleCircuitBreakerPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 0}
}

func (m *CircuitBreakerPolicy_SimpleCircuitBreakerPolicy) GetSuccessThreshold() uint32 {
	if m != nil {
		return m.SuccessThreshold
	}
	return 0
}

func (m *CircuitBreakerPolicy_SimpleCircuitBreakerPolicy) GetFailureThreshold() uint32 {
	if m != nil {
		return m.FailureThreshold
	}
	return 0
}

func (m *CircuitBreakerPolicy_SimpleCircuitBreakerPolicy) GetResetTimeoutSeconds() float64 {
	if m != nil {
		return m.ResetTimeoutSeconds
	}
	return 0
}

// Faults can be injected into the API calls by the proxy, for testing the
// failure recovery capabilities of downstream services.  Faults include
// aborting the Http request from downstream service, delaying the proxying
// of request to the upstream clusters, or both.
type HttpFaultInjection struct {
	// Delay requests before forwarding to upstream cluster, emulating
	// various failures such as network issues, overloaded upstream service, etc.
	Delay *HttpFaultInjection_Delay `protobuf:"bytes,1,opt,name=delay" json:"delay,omitempty"`
	// Abort Http request attempts and return error codes back to downstream
	// service, giving the impression that the upstream service is faulty.
	// N.B. Both delay and abort can be specified simultaneously. Delay and
	// Abort are independent of one another. For e.g., if Delay is restricted
	// to 5% of requests while Abort is restricted to 10% of requests, the
	// 10% in abort specification applies to all requests directed to the
	// service. It may be the case that one or more requests being aborted
	// were also delayed.
	Abort *HttpFaultInjection_Abort `protobuf:"bytes,2,opt,name=abort" json:"abort,omitempty"`
	// Only requests with these Http headers will be subjected to fault
	// injection
	Headers map[string]*StringMatch `protobuf:"bytes,3,rep,name=headers" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HttpFaultInjection) Reset()                    { *m = HttpFaultInjection{} }
func (m *HttpFaultInjection) String() string            { return proto.CompactTextString(m) }
func (*HttpFaultInjection) ProtoMessage()               {}
func (*HttpFaultInjection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *HttpFaultInjection) GetDelay() *HttpFaultInjection_Delay {
	if m != nil {
		return m.Delay
	}
	return nil
}

func (m *HttpFaultInjection) GetAbort() *HttpFaultInjection_Abort {
	if m != nil {
		return m.Abort
	}
	return nil
}

func (m *HttpFaultInjection) GetHeaders() map[string]*StringMatch {
	if m != nil {
		return m.Headers
	}
	return nil
}

// Either a fixed delay or exponential delay.
type HttpFaultInjection_Delay struct {
	// Types that are valid to be assigned to HttpDelayType:
	//	*HttpFaultInjection_Delay_FixedDelay
	//	*HttpFaultInjection_Delay_ExpDelay
	HttpDelayType isHttpFaultInjection_Delay_HttpDelayType `protobuf_oneof:"http_delay_type"`
	// Specify delay duration as part of Http request.
	// TODO: The semantics and syntax of the headers is undefined.
	OverrideHeaderName string `protobuf:"bytes,3,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HttpFaultInjection_Delay) Reset()                    { *m = HttpFaultInjection_Delay{} }
func (m *HttpFaultInjection_Delay) String() string            { return proto.CompactTextString(m) }
func (*HttpFaultInjection_Delay) ProtoMessage()               {}
func (*HttpFaultInjection_Delay) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 1} }

type isHttpFaultInjection_Delay_HttpDelayType interface {
	isHttpFaultInjection_Delay_HttpDelayType()
}

type HttpFaultInjection_Delay_FixedDelay struct {
	FixedDelay *HttpFaultInjection_FixedDelay `protobuf:"bytes,1,opt,name=fixed_delay,json=fixedDelay,oneof"`
}
type HttpFaultInjection_Delay_ExpDelay struct {
	ExpDelay *HttpFaultInjection_ExponentialDelay `protobuf:"bytes,2,opt,name=exp_delay,json=expDelay,oneof"`
}

func (*HttpFaultInjection_Delay_FixedDelay) isHttpFaultInjection_Delay_HttpDelayType() {}
func (*HttpFaultInjection_Delay_ExpDelay) isHttpFaultInjection_Delay_HttpDelayType()   {}

func (m *HttpFaultInjection_Delay) GetHttpDelayType() isHttpFaultInjection_Delay_HttpDelayType {
	if m != nil {
		return m.HttpDelayType
	}
	return nil
}

func (m *HttpFaultInjection_Delay) GetFixedDelay() *HttpFaultInjection_FixedDelay {
	if x, ok := m.GetHttpDelayType().(*HttpFaultInjection_Delay_FixedDelay); ok {
		return x.FixedDelay
	}
	return nil
}

func (m *HttpFaultInjection_Delay) GetExpDelay() *HttpFaultInjection_ExponentialDelay {
	if x, ok := m.GetHttpDelayType().(*HttpFaultInjection_Delay_ExpDelay); ok {
		return x.ExpDelay
	}
	return nil
}

func (m *HttpFaultInjection_Delay) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpFaultInjection_Delay) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpFaultInjection_Delay_OneofMarshaler, _HttpFaultInjection_Delay_OneofUnmarshaler, _HttpFaultInjection_Delay_OneofSizer, []interface{}{
		(*HttpFaultInjection_Delay_FixedDelay)(nil),
		(*HttpFaultInjection_Delay_ExpDelay)(nil),
	}
}

func _HttpFaultInjection_Delay_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpFaultInjection_Delay)
	// http_delay_type
	switch x := m.HttpDelayType.(type) {
	case *HttpFaultInjection_Delay_FixedDelay:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FixedDelay); err != nil {
			return err
		}
	case *HttpFaultInjection_Delay_ExpDelay:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExpDelay); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HttpFaultInjection_Delay.HttpDelayType has unexpected type %T", x)
	}
	return nil
}

func _HttpFaultInjection_Delay_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpFaultInjection_Delay)
	switch tag {
	case 1: // http_delay_type.fixed_delay
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpFaultInjection_FixedDelay)
		err := b.DecodeMessage(msg)
		m.HttpDelayType = &HttpFaultInjection_Delay_FixedDelay{msg}
		return true, err
	case 2: // http_delay_type.exp_delay
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpFaultInjection_ExponentialDelay)
		err := b.DecodeMessage(msg)
		m.HttpDelayType = &HttpFaultInjection_Delay_ExpDelay{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HttpFaultInjection_Delay_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpFaultInjection_Delay)
	// http_delay_type
	switch x := m.HttpDelayType.(type) {
	case *HttpFaultInjection_Delay_FixedDelay:
		s := proto.Size(x.FixedDelay)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HttpFaultInjection_Delay_ExpDelay:
		s := proto.Size(x.ExpDelay)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Add a fixed delay before forwarding the request to upstream cluster
type HttpFaultInjection_FixedDelay struct {
	// percentage of requests on which the delay will be injected
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// delay duration in seconds.nanoseconds
	FixedDelaySeconds float64 `protobuf:"fixed64,2,opt,name=fixed_delay_seconds,json=fixedDelaySeconds" json:"fixed_delay_seconds,omitempty"`
}

func (m *HttpFaultInjection_FixedDelay) Reset()         { *m = HttpFaultInjection_FixedDelay{} }
func (m *HttpFaultInjection_FixedDelay) String() string { return proto.CompactTextString(m) }
func (*HttpFaultInjection_FixedDelay) ProtoMessage()    {}
func (*HttpFaultInjection_FixedDelay) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 2}
}

func (m *HttpFaultInjection_FixedDelay) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *HttpFaultInjection_FixedDelay) GetFixedDelaySeconds() float64 {
	if m != nil {
		return m.FixedDelaySeconds
	}
	return 0
}

// Add a delay (based on an exponential function) before forwarding the
// request to upstream cluster
type HttpFaultInjection_ExponentialDelay struct {
	// percentage of requests on which the delay will be injected
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// mean delay needed to derive the exponential delay values
	MeanDelaySeconds float64 `protobuf:"fixed64,2,opt,name=mean_delay_seconds,json=meanDelaySeconds" json:"mean_delay_seconds,omitempty"`
}

func (m *HttpFaultInjection_ExponentialDelay) Reset()         { *m = HttpFaultInjection_ExponentialDelay{} }
func (m *HttpFaultInjection_ExponentialDelay) String() string { return proto.CompactTextString(m) }
func (*HttpFaultInjection_ExponentialDelay) ProtoMessage()    {}
func (*HttpFaultInjection_ExponentialDelay) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 3}
}

func (m *HttpFaultInjection_ExponentialDelay) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *HttpFaultInjection_ExponentialDelay) GetMeanDelaySeconds() float64 {
	if m != nil {
		return m.MeanDelaySeconds
	}
	return 0
}

// Abort Http request attempts and return error codes back to downstream
// service.
type HttpFaultInjection_Abort struct {
	// percentage of requests to be aborted with the error code provided.
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// Error code to use to abort the Http request. Requests can be aborted
	// either with Http/1.1 status codes | http2 error codes or gRPC status
	// codes.
	//
	// Types that are valid to be assigned to ErrorType:
	//	*HttpFaultInjection_Abort_GrpcStatus
	//	*HttpFaultInjection_Abort_Http2Error
	//	*HttpFaultInjection_Abort_HttpStatus
	ErrorType isHttpFaultInjection_Abort_ErrorType `protobuf_oneof:"error_type"`
	// Specify abort code as part of Http request.
	// TODO: The semantics and syntax of the headers is undefined.
	OverrideHeaderName string `protobuf:"bytes,5,opt,name=override_header_name,json=overrideHeaderName" json:"override_header_name,omitempty"`
}

func (m *HttpFaultInjection_Abort) Reset()                    { *m = HttpFaultInjection_Abort{} }
func (m *HttpFaultInjection_Abort) String() string            { return proto.CompactTextString(m) }
func (*HttpFaultInjection_Abort) ProtoMessage()               {}
func (*HttpFaultInjection_Abort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 4} }

type isHttpFaultInjection_Abort_ErrorType interface {
	isHttpFaultInjection_Abort_ErrorType()
}

type HttpFaultInjection_Abort_GrpcStatus struct {
	GrpcStatus string `protobuf:"bytes,2,opt,name=grpc_status,json=grpcStatus,oneof"`
}
type HttpFaultInjection_Abort_Http2Error struct {
	Http2Error string `protobuf:"bytes,3,opt,name=http2_error,json=http2Error,oneof"`
}
type HttpFaultInjection_Abort_HttpStatus struct {
	HttpStatus uint32 `protobuf:"varint,4,opt,name=http_status,json=httpStatus,oneof"`
}

func (*HttpFaultInjection_Abort_GrpcStatus) isHttpFaultInjection_Abort_ErrorType() {}
func (*HttpFaultInjection_Abort_Http2Error) isHttpFaultInjection_Abort_ErrorType() {}
func (*HttpFaultInjection_Abort_HttpStatus) isHttpFaultInjection_Abort_ErrorType() {}

func (m *HttpFaultInjection_Abort) GetErrorType() isHttpFaultInjection_Abort_ErrorType {
	if m != nil {
		return m.ErrorType
	}
	return nil
}

func (m *HttpFaultInjection_Abort) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *HttpFaultInjection_Abort) GetGrpcStatus() string {
	if x, ok := m.GetErrorType().(*HttpFaultInjection_Abort_GrpcStatus); ok {
		return x.GrpcStatus
	}
	return ""
}

func (m *HttpFaultInjection_Abort) GetHttp2Error() string {
	if x, ok := m.GetErrorType().(*HttpFaultInjection_Abort_Http2Error); ok {
		return x.Http2Error
	}
	return ""
}

func (m *HttpFaultInjection_Abort) GetHttpStatus() uint32 {
	if x, ok := m.GetErrorType().(*HttpFaultInjection_Abort_HttpStatus); ok {
		return x.HttpStatus
	}
	return 0
}

func (m *HttpFaultInjection_Abort) GetOverrideHeaderName() string {
	if m != nil {
		return m.OverrideHeaderName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpFaultInjection_Abort) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpFaultInjection_Abort_OneofMarshaler, _HttpFaultInjection_Abort_OneofUnmarshaler, _HttpFaultInjection_Abort_OneofSizer, []interface{}{
		(*HttpFaultInjection_Abort_GrpcStatus)(nil),
		(*HttpFaultInjection_Abort_Http2Error)(nil),
		(*HttpFaultInjection_Abort_HttpStatus)(nil),
	}
}

func _HttpFaultInjection_Abort_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpFaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *HttpFaultInjection_Abort_GrpcStatus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.GrpcStatus)
	case *HttpFaultInjection_Abort_Http2Error:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Http2Error)
	case *HttpFaultInjection_Abort_HttpStatus:
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		return fmt.Errorf("HttpFaultInjection_Abort.ErrorType has unexpected type %T", x)
	}
	return nil
}

func _HttpFaultInjection_Abort_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpFaultInjection_Abort)
	switch tag {
	case 2: // error_type.grpc_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ErrorType = &HttpFaultInjection_Abort_GrpcStatus{x}
		return true, err
	case 3: // error_type.http2_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ErrorType = &HttpFaultInjection_Abort_Http2Error{x}
		return true, err
	case 4: // error_type.http_status
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ErrorType = &HttpFaultInjection_Abort_HttpStatus{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _HttpFaultInjection_Abort_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpFaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *HttpFaultInjection_Abort_GrpcStatus:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.GrpcStatus)))
		n += len(x.GrpcStatus)
	case *HttpFaultInjection_Abort_Http2Error:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Http2Error)))
		n += len(x.Http2Error)
	case *HttpFaultInjection_Abort_HttpStatus:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Faults can be injected into the L4 traffic forwarded by the proxy, for
// testing the failure recovery capabilities of downstream services.
// Faults include terminating established Tcp connections, throttling the
// upstream/downstream bandwidth (for Tcp|Udp), or both.
type L4FaultInjection struct {
	// We first throttle (if set) and then terminate the connection.
	Throttle  *L4FaultInjection_Throttle  `protobuf:"bytes,1,opt,name=throttle" json:"throttle,omitempty"`
	Terminate *L4FaultInjection_Terminate `protobuf:"bytes,2,opt,name=terminate" json:"terminate,omitempty"`
}

func (m *L4FaultInjection) Reset()                    { *m = L4FaultInjection{} }
func (m *L4FaultInjection) String() string            { return proto.CompactTextString(m) }
func (*L4FaultInjection) ProtoMessage()               {}
func (*L4FaultInjection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *L4FaultInjection) GetThrottle() *L4FaultInjection_Throttle {
	if m != nil {
		return m.Throttle
	}
	return nil
}

func (m *L4FaultInjection) GetTerminate() *L4FaultInjection_Terminate {
	if m != nil {
		return m.Terminate
	}
	return nil
}

// Bandwidth throttling for Tcp and Udp connections
type L4FaultInjection_Throttle struct {
	// percentage of connections to throttle.
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// bandwidth limit in "bits" per second between downstream and proxy
	DownstreamLimitBps uint64 `protobuf:"varint,2,opt,name=downstream_limit_bps,json=downstreamLimitBps" json:"downstream_limit_bps,omitempty"`
	// bandwidth limits in "bits" per second between proxy and upstream
	UpstreamLimitBps uint64 `protobuf:"varint,3,opt,name=upstream_limit_bps,json=upstreamLimitBps" json:"upstream_limit_bps,omitempty"`
	// Types that are valid to be assigned to ThrottleAfter:
	//	*L4FaultInjection_Throttle_ThrottleAfterSeconds
	//	*L4FaultInjection_Throttle_ThrottleAfterBytes
	ThrottleAfter isL4FaultInjection_Throttle_ThrottleAfter `protobuf_oneof:"throttle_after"`
	// Stop throttling after the given duration. If not set, the connection
	// will be throttled for its lifetime.
	ThrottleForSeconds *google_protobuf1.DoubleValue `protobuf:"bytes,6,opt,name=throttle_for_seconds,json=throttleForSeconds" json:"throttle_for_seconds,omitempty"`
}

func (m *L4FaultInjection_Throttle) Reset()                    { *m = L4FaultInjection_Throttle{} }
func (m *L4FaultInjection_Throttle) String() string            { return proto.CompactTextString(m) }
func (*L4FaultInjection_Throttle) ProtoMessage()               {}
func (*L4FaultInjection_Throttle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 0} }

type isL4FaultInjection_Throttle_ThrottleAfter interface {
	isL4FaultInjection_Throttle_ThrottleAfter()
}

type L4FaultInjection_Throttle_ThrottleAfterSeconds struct {
	ThrottleAfterSeconds float64 `protobuf:"fixed64,4,opt,name=throttle_after_seconds,json=throttleAfterSeconds,oneof"`
}
type L4FaultInjection_Throttle_ThrottleAfterBytes struct {
	ThrottleAfterBytes float64 `protobuf:"fixed64,5,opt,name=throttle_after_bytes,json=throttleAfterBytes,oneof"`
}

func (*L4FaultInjection_Throttle_ThrottleAfterSeconds) isL4FaultInjection_Throttle_ThrottleAfter() {}
func (*L4FaultInjection_Throttle_ThrottleAfterBytes) isL4FaultInjection_Throttle_ThrottleAfter()   {}

func (m *L4FaultInjection_Throttle) GetThrottleAfter() isL4FaultInjection_Throttle_ThrottleAfter {
	if m != nil {
		return m.ThrottleAfter
	}
	return nil
}

func (m *L4FaultInjection_Throttle) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetDownstreamLimitBps() uint64 {
	if m != nil {
		return m.DownstreamLimitBps
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetUpstreamLimitBps() uint64 {
	if m != nil {
		return m.UpstreamLimitBps
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetThrottleAfterSeconds() float64 {
	if x, ok := m.GetThrottleAfter().(*L4FaultInjection_Throttle_ThrottleAfterSeconds); ok {
		return x.ThrottleAfterSeconds
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetThrottleAfterBytes() float64 {
	if x, ok := m.GetThrottleAfter().(*L4FaultInjection_Throttle_ThrottleAfterBytes); ok {
		return x.ThrottleAfterBytes
	}
	return 0
}

func (m *L4FaultInjection_Throttle) GetThrottleForSeconds() *google_protobuf1.DoubleValue {
	if m != nil {
		return m.ThrottleForSeconds
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*L4FaultInjection_Throttle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _L4FaultInjection_Throttle_OneofMarshaler, _L4FaultInjection_Throttle_OneofUnmarshaler, _L4FaultInjection_Throttle_OneofSizer, []interface{}{
		(*L4FaultInjection_Throttle_ThrottleAfterSeconds)(nil),
		(*L4FaultInjection_Throttle_ThrottleAfterBytes)(nil),
	}
}

func _L4FaultInjection_Throttle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*L4FaultInjection_Throttle)
	// throttle_after
	switch x := m.ThrottleAfter.(type) {
	case *L4FaultInjection_Throttle_ThrottleAfterSeconds:
		b.EncodeVarint(4<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.ThrottleAfterSeconds))
	case *L4FaultInjection_Throttle_ThrottleAfterBytes:
		b.EncodeVarint(5<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.ThrottleAfterBytes))
	case nil:
	default:
		return fmt.Errorf("L4FaultInjection_Throttle.ThrottleAfter has unexpected type %T", x)
	}
	return nil
}

func _L4FaultInjection_Throttle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*L4FaultInjection_Throttle)
	switch tag {
	case 4: // throttle_after.throttle_after_seconds
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ThrottleAfter = &L4FaultInjection_Throttle_ThrottleAfterSeconds{math.Float64frombits(x)}
		return true, err
	case 5: // throttle_after.throttle_after_bytes
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ThrottleAfter = &L4FaultInjection_Throttle_ThrottleAfterBytes{math.Float64frombits(x)}
		return true, err
	default:
		return false, nil
	}
}

func _L4FaultInjection_Throttle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*L4FaultInjection_Throttle)
	// throttle_after
	switch x := m.ThrottleAfter.(type) {
	case *L4FaultInjection_Throttle_ThrottleAfterSeconds:
		n += proto.SizeVarint(4<<3 | proto.WireFixed64)
		n += 8
	case *L4FaultInjection_Throttle_ThrottleAfterBytes:
		n += proto.SizeVarint(5<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Abruptly reset (terminate) the Tcp connection after it has been
// established, emulating remote server crash or link failure.
type L4FaultInjection_Terminate struct {
	// percentage of established Tcp connections to be terminated/reset
	Percent float32 `protobuf:"fixed32,1,opt,name=percent" json:"percent,omitempty"`
	// TODO: see if it makes sense to create a generic Duration type to
	// express time interval related configs.
	TerminateAfterSeconds float64 `protobuf:"fixed64,2,opt,name=terminate_after_seconds,json=terminateAfterSeconds" json:"terminate_after_seconds,omitempty"`
}

func (m *L4FaultInjection_Terminate) Reset()                    { *m = L4FaultInjection_Terminate{} }
func (m *L4FaultInjection_Terminate) String() string            { return proto.CompactTextString(m) }
func (*L4FaultInjection_Terminate) ProtoMessage()               {}
func (*L4FaultInjection_Terminate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 1} }

func (m *L4FaultInjection_Terminate) GetPercent() float32 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *L4FaultInjection_Terminate) GetTerminateAfterSeconds() float64 {
	if m != nil {
		return m.TerminateAfterSeconds
	}
	return 0
}

func init() {
	proto.RegisterType((*ProxyConfig)(nil), "istio.proxy.v1alpha.config.ProxyConfig")
	proto.RegisterType((*RouteRule)(nil), "istio.proxy.v1alpha.config.RouteRule")
	proto.RegisterType((*L4RouteRule)(nil), "istio.proxy.v1alpha.config.L4RouteRule")
	proto.RegisterType((*HttpRouteRule)(nil), "istio.proxy.v1alpha.config.HttpRouteRule")
	proto.RegisterType((*L4MatchCondition)(nil), "istio.proxy.v1alpha.config.L4MatchCondition")
	proto.RegisterType((*L4MatchAttributes)(nil), "istio.proxy.v1alpha.config.L4MatchAttributes")
	proto.RegisterType((*ClusterIdentifier)(nil), "istio.proxy.v1alpha.config.ClusterIdentifier")
	proto.RegisterType((*WeightedCluster)(nil), "istio.proxy.v1alpha.config.WeightedCluster")
	proto.RegisterType((*HttpMatchCondition)(nil), "istio.proxy.v1alpha.config.HttpMatchCondition")
	proto.RegisterType((*StringMatch)(nil), "istio.proxy.v1alpha.config.StringMatch")
	proto.RegisterType((*UpstreamCluster)(nil), "istio.proxy.v1alpha.config.UpstreamCluster")
	proto.RegisterType((*LoadBalancingPolicy)(nil), "istio.proxy.v1alpha.config.LoadBalancingPolicy")
	proto.RegisterType((*TimeoutPolicy)(nil), "istio.proxy.v1alpha.config.TimeoutPolicy")
	proto.RegisterType((*TimeoutPolicy_SimpleTimeoutPolicy)(nil), "istio.proxy.v1alpha.config.TimeoutPolicy.SimpleTimeoutPolicy")
	proto.RegisterType((*RetryPolicy)(nil), "istio.proxy.v1alpha.config.RetryPolicy")
	proto.RegisterType((*RetryPolicy_SimpleRetryPolicy)(nil), "istio.proxy.v1alpha.config.RetryPolicy.SimpleRetryPolicy")
	proto.RegisterType((*CircuitBreakerPolicy)(nil), "istio.proxy.v1alpha.config.CircuitBreakerPolicy")
	proto.RegisterType((*CircuitBreakerPolicy_SimpleCircuitBreakerPolicy)(nil), "istio.proxy.v1alpha.config.CircuitBreakerPolicy.SimpleCircuitBreakerPolicy")
	proto.RegisterType((*HttpFaultInjection)(nil), "istio.proxy.v1alpha.config.HttpFaultInjection")
	proto.RegisterType((*HttpFaultInjection_Delay)(nil), "istio.proxy.v1alpha.config.HttpFaultInjection.Delay")
	proto.RegisterType((*HttpFaultInjection_FixedDelay)(nil), "istio.proxy.v1alpha.config.HttpFaultInjection.FixedDelay")
	proto.RegisterType((*HttpFaultInjection_ExponentialDelay)(nil), "istio.proxy.v1alpha.config.HttpFaultInjection.ExponentialDelay")
	proto.RegisterType((*HttpFaultInjection_Abort)(nil), "istio.proxy.v1alpha.config.HttpFaultInjection.Abort")
	proto.RegisterType((*L4FaultInjection)(nil), "istio.proxy.v1alpha.config.L4FaultInjection")
	proto.RegisterType((*L4FaultInjection_Throttle)(nil), "istio.proxy.v1alpha.config.L4FaultInjection.Throttle")
	proto.RegisterType((*L4FaultInjection_Terminate)(nil), "istio.proxy.v1alpha.config.L4FaultInjection.Terminate")
	proto.RegisterEnum("istio.proxy.v1alpha.config.L4MatchAttributes_L4Protocol", L4MatchAttributes_L4Protocol_name, L4MatchAttributes_L4Protocol_value)
	proto.RegisterEnum("istio.proxy.v1alpha.config.LoadBalancingPolicy_SimpleLBPolicy", LoadBalancingPolicy_SimpleLBPolicy_name, LoadBalancingPolicy_SimpleLBPolicy_value)
}

func init() { proto.RegisterFile("cfg.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1793 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x58, 0x4f, 0x6f, 0xe3, 0xc6,
	0x15, 0x17, 0x25, 0x4b, 0x96, 0x1e, 0xfd, 0x47, 0x1e, 0x7b, 0xb7, 0xaa, 0x50, 0x04, 0xae, 0x80,
	0x22, 0x5b, 0x24, 0xd5, 0x6e, 0x15, 0x67, 0x93, 0x6d, 0x90, 0x06, 0x96, 0xed, 0xad, 0x9c, 0x3a,
	0x5e, 0x67, 0x2c, 0xa7, 0x6d, 0xd0, 0x86, 0xa0, 0xc8, 0x91, 0xc4, 0x2c, 0x45, 0x12, 0x33, 0xc3,
	0x5d, 0xeb, 0x2b, 0x14, 0xe8, 0x07, 0xe8, 0x57, 0x28, 0x7a, 0x6c, 0x4f, 0x3d, 0xf4, 0xd0, 0x5b,
	0x7b, 0xeb, 0x17, 0xc9, 0xa9, 0xbd, 0x15, 0x28, 0xe6, 0x0f, 0x29, 0x52, 0xb6, 0xb4, 0x96, 0x0b,
	0xb4, 0xe8, 0x8d, 0xf3, 0xfe, 0xfc, 0x66, 0xde, 0xef, 0xbd, 0x37, 0x7c, 0x24, 0xd4, 0x9c, 0xe1,
	0xa8, 0x1d, 0xd1, 0x90, 0x87, 0xa8, 0xe9, 0x31, 0xee, 0x85, 0x62, 0x71, 0x3d, 0x6d, 0xbf, 0xfa,
	0xa1, 0xed, 0x47, 0x63, 0xbb, 0xed, 0x84, 0xc1, 0xd0, 0x1b, 0x35, 0xbf, 0x3d, 0x0a, 0xc3, 0x91,
	0x4f, 0x1e, 0x4b, 0xcb, 0x41, 0x3c, 0x7c, 0x6c, 0x07, 0x53, 0xe5, 0xd6, 0x7c, 0x6b, 0x5e, 0xf5,
	0x9a, 0xda, 0x51, 0x44, 0x28, 0x53, 0xfa, 0xd6, 0xdf, 0x0c, 0x30, 0x2f, 0x04, 0xe6, 0x91, 0x84,
	0x42, 0x4d, 0xa8, 0x52, 0xf2, 0xca, 0x63, 0x5e, 0x18, 0x34, 0x8c, 0x7d, 0xe3, 0x51, 0x19, 0xa7,
	0x6b, 0xf4, 0x1c, 0x4c, 0x1a, 0xc6, 0x9c, 0x58, 0x34, 0xf6, 0x09, 0x6b, 0x14, 0xf7, 0x4b, 0x8f,
	0xcc, 0xce, 0xf7, 0xda, 0x8b, 0x0f, 0xd6, 0xc6, 0xc2, 0x1c, 0xc7, 0x3e, 0xc1, 0x40, 0x93, 0x47,
	0x86, 0x7e, 0x0e, 0x3b, 0x71, 0xc4, 0x38, 0x25, 0xf6, 0xc4, 0x72, 0xfc, 0x98, 0x71, 0x42, 0x59,
	0xa3, 0x24, 0xd1, 0xde, 0x59, 0x86, 0x76, 0xa5, 0x9d, 0x8e, 0x94, 0x0f, 0xae, 0xc7, 0x79, 0x01,
	0x6b, 0xfd, 0xd9, 0x80, 0x5a, 0xba, 0x27, 0xda, 0x07, 0xd3, 0x25, 0x8c, 0x7b, 0x81, 0xcd, 0x93,
	0x70, 0x6a, 0x38, 0x2b, 0x42, 0x87, 0x50, 0xf1, 0xed, 0x29, 0xa1, 0x07, 0x8d, 0xe2, 0xbe, 0xf1,
	0xc8, 0xec, 0xbc, 0xbd, 0x6c, 0xfb, 0xb3, 0x83, 0x14, 0xba, 0x57, 0xc0, 0xda, 0x11, 0x7d, 0x02,
	0x6b, 0x63, 0xce, 0xa3, 0x46, 0x49, 0x02, 0x7c, 0x7f, 0x19, 0x40, 0x8f, 0xf3, 0x28, 0x0b, 0x21,
	0x1d, 0xbb, 0x1b, 0x00, 0x33, 0x56, 0x5b, 0xdf, 0x18, 0x60, 0x66, 0x36, 0x42, 0x5d, 0x28, 0x4f,
	0x6c, 0xee, 0x8c, 0xe5, 0xe9, 0xcd, 0xce, 0xbb, 0xcb, 0x0f, 0xf8, 0x99, 0x30, 0x3d, 0x0a, 0x03,
	0xd7, 0x13, 0xe1, 0x61, 0xe5, 0x2a, 0xf8, 0x7e, 0x4d, 0xbc, 0xd1, 0x98, 0x13, 0x77, 0xc6, 0x77,
	0xf1, 0xcd, 0x7c, 0xff, 0x4c, 0x3b, 0xa5, 0x7c, 0xbf, 0xce, 0x0b, 0x98, 0x38, 0xdd, 0xd0, 0x8e,
	0x7d, 0xae, 0xa3, 0x7f, 0xc3, 0xe9, 0x9e, 0x0b, 0xd3, 0xd3, 0xe0, 0x6b, 0xe2, 0xa8, 0xd3, 0x49,
	0xd7, 0xd6, 0xef, 0x8b, 0xb0, 0x99, 0x63, 0x06, 0x1d, 0xe7, 0x63, 0x6e, 0xbf, 0x89, 0xd3, 0xff,
	0x76, 0xd4, 0xc7, 0xf9, 0xa8, 0xdf, 0x78, 0xbe, 0x5b, 0xe3, 0x46, 0xef, 0x83, 0xe9, 0xc4, 0x8c,
	0x87, 0x13, 0xcb, 0x9b, 0x44, 0x7e, 0x63, 0x4d, 0x62, 0xed, 0xb5, 0x55, 0xbf, 0xb6, 0x93, 0x7e,
	0x6d, 0x1f, 0x06, 0x53, 0x0c, 0xca, 0xf0, 0x74, 0x12, 0xf9, 0xad, 0x3f, 0x1a, 0x50, 0x9f, 0x4f,
	0x34, 0xfa, 0x1c, 0x36, 0xfc, 0x03, 0x9b, 0x73, 0xea, 0x0d, 0x62, 0x4e, 0x98, 0x26, 0xee, 0x07,
	0x77, 0x28, 0x96, 0xc3, 0xd4, 0x09, 0xe7, 0x20, 0xd0, 0x39, 0x98, 0x8c, 0x3a, 0x09, 0x73, 0xba,
	0x3f, 0x96, 0x22, 0x6a, 0x7e, 0x4e, 0x5d, 0x12, 0x70, 0x6f, 0xe8, 0x11, 0x8a, 0x81, 0x51, 0x47,
	0x4b, 0x5b, 0x7f, 0x29, 0xc2, 0xce, 0x8d, 0x3d, 0x51, 0x0b, 0x36, 0xc5, 0x2e, 0x5e, 0x64, 0xb1,
	0x78, 0x10, 0x10, 0xde, 0x30, 0xf6, 0x4b, 0xa2, 0x49, 0x19, 0x75, 0x4e, 0xa3, 0x4b, 0x29, 0x42,
	0x1f, 0x40, 0x55, 0xd8, 0x44, 0x21, 0xe5, 0xfa, 0x18, 0xdf, 0xb9, 0xc1, 0xd2, 0xd5, 0x69, 0xc0,
	0xdf, 0xeb, 0x7c, 0x61, 0xfb, 0x31, 0xc1, 0xeb, 0x8c, 0x3a, 0x17, 0x21, 0xe5, 0x02, 0xdc, 0x65,
	0x3c, 0x03, 0x5e, 0x52, 0xe0, 0x2e, 0xe3, 0x59, 0x70, 0x61, 0x23, 0xc1, 0xd7, 0xee, 0x02, 0xee,
	0x32, 0x2e, 0xc1, 0xfb, 0x50, 0x95, 0x06, 0x4e, 0xe8, 0x37, 0xca, 0xfb, 0xc6, 0xa3, 0xad, 0xce,
	0x87, 0x2b, 0xd1, 0xdd, 0x3e, 0x3b, 0xb8, 0xd0, 0xfe, 0x38, 0x45, 0x6a, 0xbd, 0x05, 0x30, 0x93,
	0xa3, 0x75, 0x28, 0xf5, 0x8f, 0x2e, 0xea, 0x05, 0xf1, 0x70, 0x75, 0x7c, 0x51, 0x37, 0x5a, 0x1f,
	0xc1, 0xce, 0x0d, 0x9a, 0x11, 0x82, 0xb5, 0xc0, 0x9e, 0x10, 0x7d, 0xc1, 0xc9, 0x67, 0x21, 0xe3,
	0xf6, 0x48, 0x15, 0x7c, 0x0d, 0xcb, 0xe7, 0xd6, 0x14, 0xb6, 0xe7, 0x8a, 0x5b, 0x64, 0x59, 0x84,
	0x9f, 0x64, 0xd9, 0xb8, 0x57, 0x96, 0x5d, 0xc6, 0x13, 0xbc, 0x87, 0x50, 0x51, 0xed, 0x22, 0x33,
	0xb5, 0x89, 0xf5, 0xaa, 0xf5, 0x9b, 0x35, 0x40, 0x37, 0x5b, 0xf5, 0xff, 0xa0, 0x6e, 0x45, 0x44,
	0xcc, 0x19, 0x93, 0x09, 0x91, 0xdd, 0x5e, 0xc3, 0x7a, 0x85, 0x4e, 0xa0, 0x66, 0xc7, 0x7c, 0x1c,
	0x52, 0x8f, 0x4f, 0x75, 0xe5, 0x2c, 0x7d, 0x7b, 0x5c, 0x72, 0xea, 0x05, 0x23, 0x79, 0x76, 0x3c,
	0xf3, 0x44, 0xcf, 0xa0, 0x14, 0x53, 0x4f, 0x56, 0xd0, 0x0a, 0x00, 0xc2, 0x07, 0x5d, 0xc1, 0xfa,
	0x98, 0xd8, 0xae, 0xb8, 0xd6, 0x2a, 0xf2, 0x5a, 0xfb, 0x68, 0xb5, 0x8b, 0xb2, 0xdd, 0x53, 0xde,
	0x27, 0x01, 0xa7, 0x53, 0x9c, 0x60, 0x35, 0x1d, 0xd8, 0xc8, 0x2a, 0x50, 0x1d, 0x4a, 0x2f, 0xc9,
	0x54, 0x17, 0x97, 0x78, 0x44, 0x1f, 0x43, 0xf9, 0x95, 0x68, 0x86, 0xbb, 0xbc, 0x34, 0xb3, 0xa7,
	0x56, 0x5e, 0x3f, 0x2a, 0x7e, 0x68, 0xb4, 0x08, 0x98, 0x19, 0x0d, 0x7a, 0x08, 0x65, 0x72, 0x6d,
	0x3b, 0x5c, 0xed, 0xd2, 0x2b, 0x60, 0xb5, 0x44, 0x0d, 0xa8, 0x44, 0x94, 0x0c, 0xbd, 0x6b, 0xb9,
	0x95, 0x50, 0xe8, 0xb5, 0xf0, 0xa0, 0x64, 0x44, 0xae, 0x55, 0x56, 0x84, 0x87, 0x5c, 0x8a, 0xb7,
	0xa9, 0xbc, 0xfe, 0x2d, 0x3e, 0x8d, 0x48, 0xeb, 0x4f, 0x25, 0xd8, 0x9e, 0x9b, 0x1a, 0xd0, 0x4f,
	0x60, 0xfd, 0x3f, 0x2a, 0xf7, 0xc4, 0x1b, 0x75, 0xe0, 0xc1, 0x98, 0xd8, 0x3e, 0x1f, 0x5b, 0xce,
	0x98, 0x38, 0x2f, 0x2d, 0x12, 0xb8, 0x51, 0xe8, 0x05, 0xaa, 0xf4, 0x6b, 0x78, 0x57, 0x29, 0x8f,
	0x84, 0xee, 0x44, 0xab, 0xd0, 0x19, 0xd4, 0xfc, 0x81, 0x15, 0x85, 0xbe, 0xe7, 0x4c, 0xf5, 0xeb,
	0xe3, 0xf1, 0xd2, 0x6a, 0x0f, 0x6d, 0xb7, 0x6b, 0xfb, 0x76, 0xe0, 0x78, 0xc1, 0xe8, 0x42, 0xba,
	0xe1, 0xaa, 0x3f, 0x50, 0x4f, 0xe8, 0x08, 0xd6, 0xb9, 0x37, 0x21, 0x61, 0x9c, 0xdc, 0x5d, 0x4b,
	0xc7, 0x8f, 0xbe, 0x32, 0xd5, 0x28, 0x89, 0xa7, 0xc8, 0x26, 0x25, 0x9c, 0x4e, 0xef, 0x52, 0x83,
	0x58, 0x18, 0x6a, 0x00, 0xe5, 0x85, 0x7e, 0x01, 0xdb, 0x8e, 0x47, 0x9d, 0xd8, 0xe3, 0xd6, 0x80,
	0x12, 0xfb, 0x25, 0xa1, 0x8d, 0x8a, 0x04, 0x7a, 0xb2, 0x94, 0x56, 0xe5, 0xd2, 0x55, 0x1e, 0x1a,
	0x71, 0xcb, 0xc9, 0x49, 0x5b, 0xff, 0x32, 0x60, 0xf7, 0x16, 0x02, 0x50, 0x3f, 0x73, 0xdf, 0x6d,
	0x75, 0x7e, 0xbc, 0x22, 0x7f, 0xed, 0x4b, 0xf1, 0xbe, 0x25, 0x67, 0x5d, 0xb5, 0x14, 0x73, 0x98,
	0xbc, 0x31, 0x3f, 0xc8, 0xbf, 0x8f, 0x8b, 0x8b, 0xdf, 0xc7, 0xbd, 0x42, 0xee, 0x8d, 0xfc, 0x29,
	0x6c, 0xe5, 0x21, 0xd1, 0x36, 0x98, 0xf8, 0xc5, 0xd5, 0xf9, 0xb1, 0x85, 0x5f, 0x74, 0x4f, 0xcf,
	0xeb, 0x05, 0xb4, 0x05, 0x70, 0x76, 0x72, 0x78, 0xd9, 0xb7, 0x8e, 0x5e, 0x9c, 0x9f, 0xd7, 0x0d,
	0x64, 0xc2, 0xfa, 0xe9, 0x85, 0xd5, 0x3b, 0xbc, 0xec, 0xd5, 0x8b, 0x08, 0xa0, 0x82, 0x0f, 0xcf,
	0x8f, 0x5f, 0x7c, 0x56, 0x2f, 0x75, 0xcd, 0x4c, 0x7d, 0xb4, 0xfe, 0x50, 0x84, 0xcd, 0x5c, 0xd2,
	0xd0, 0x10, 0xb6, 0x98, 0xdc, 0xca, 0x4a, 0xf2, 0xae, 0x4a, 0xf8, 0xe3, 0x3b, 0xe7, 0x5d, 0x47,
	0x9f, 0x93, 0xf5, 0x0a, 0x78, 0x93, 0x65, 0xc5, 0xf7, 0xe6, 0xa2, 0x19, 0xc1, 0xee, 0x2d, 0x1b,
	0xa0, 0xb7, 0x61, 0x5b, 0x1f, 0xd8, 0x62, 0xc4, 0x09, 0x03, 0x57, 0x5d, 0xf5, 0x06, 0xde, 0xd2,
	0xe2, 0x4b, 0x25, 0x45, 0x4f, 0x60, 0x2f, 0x7c, 0x45, 0x28, 0xf5, 0x5c, 0x62, 0xa9, 0x0b, 0xc9,
	0x92, 0xa9, 0x56, 0x2d, 0x85, 0x12, 0x9d, 0xba, 0xa0, 0xce, 0xed, 0x09, 0xe9, 0xd6, 0x21, 0xc1,
	0x48, 0x68, 0xfb, 0x6d, 0x11, 0xcc, 0x4c, 0xa1, 0xa2, 0xaf, 0x60, 0x43, 0x93, 0xa6, 0xea, 0x5c,
	0x51, 0xf6, 0xec, 0x8e, 0x75, 0xae, 0x09, 0xcb, 0x48, 0x7a, 0x05, 0x6c, 0xb2, 0x99, 0xf0, 0xfe,
	0x64, 0xd9, 0xb0, 0x73, 0x03, 0x5c, 0x7c, 0x80, 0xd9, 0x9c, 0x93, 0x49, 0xc4, 0x15, 0x47, 0x9b,
	0x38, 0x5d, 0xdf, 0x83, 0x9d, 0x2d, 0xd8, 0x90, 0x41, 0x27, 0xdc, 0xfc, 0xa3, 0x08, 0x7b, 0xb7,
	0xf5, 0x1e, 0xfa, 0x1a, 0x6a, 0x9a, 0x24, 0x67, 0xa0, 0x19, 0xfa, 0xe9, 0xaa, 0x0d, 0xac, 0xa9,
	0xba, 0x4d, 0xd5, 0x2b, 0xe0, 0xaa, 0xc2, 0x3f, 0x1a, 0xdc, 0x9f, 0xb0, 0xdf, 0x19, 0xd0, 0x5c,
	0xbc, 0x07, 0x7a, 0x07, 0x76, 0x58, 0xec, 0x38, 0x84, 0x31, 0x8b, 0x8f, 0x29, 0x61, 0xe3, 0xd0,
	0x77, 0x35, 0x87, 0x75, 0xad, 0xe8, 0x27, 0x72, 0x61, 0x3c, 0xb4, 0x3d, 0x3f, 0xa6, 0x24, 0x63,
	0xac, 0x86, 0x96, 0xba, 0x56, 0xcc, 0x8c, 0x3b, 0xf0, 0x80, 0x12, 0x46, 0xb8, 0x35, 0x5f, 0xc5,
	0x25, 0x59, 0xc5, 0xbb, 0x52, 0xd9, 0xcf, 0x95, 0xb2, 0x68, 0x65, 0x27, 0x6d, 0xe5, 0x7f, 0xae,
	0xab, 0xf9, 0x27, 0xff, 0x29, 0x80, 0x3e, 0x85, 0xb2, 0x4b, 0x7c, 0x3b, 0xa9, 0xc9, 0x83, 0xd5,
	0xbe, 0x24, 0xda, 0xc7, 0xc2, 0x17, 0x2b, 0x08, 0x81, 0x65, 0x0f, 0x66, 0x33, 0xf2, 0xaa, 0x58,
	0x87, 0xc2, 0x17, 0x2b, 0x88, 0xec, 0x68, 0x51, 0xba, 0xdb, 0x68, 0x31, 0x87, 0xf6, 0xbf, 0x1b,
	0x2d, 0x9a, 0xbf, 0x2e, 0x42, 0x59, 0x12, 0x83, 0x7e, 0x09, 0xe6, 0xd0, 0xbb, 0x26, 0xae, 0x95,
	0xe5, 0xf8, 0xd9, 0x8a, 0x91, 0x3c, 0x17, 0x08, 0x12, 0x4f, 0x14, 0xe3, 0x30, 0x5d, 0xa1, 0xaf,
	0xa0, 0x46, 0xae, 0x23, 0x8d, 0xad, 0x8e, 0xfb, 0xc9, 0x8a, 0xd8, 0x27, 0xd7, 0x51, 0x18, 0x88,
	0xc1, 0xc2, 0xf6, 0x93, 0x1d, 0xaa, 0xe4, 0x3a, 0x52, 0xf8, 0x8b, 0x9a, 0xbd, 0xb4, 0xb0, 0xd9,
	0x77, 0x60, 0x7b, 0xcc, 0xb9, 0x3e, 0x92, 0x1c, 0x80, 0x9a, 0x5f, 0x00, 0xcc, 0x02, 0x40, 0x0d,
	0x58, 0x8f, 0x08, 0x75, 0x48, 0xa0, 0xde, 0x1b, 0x45, 0x9c, 0x2c, 0x51, 0x1b, 0x76, 0x33, 0x54,
	0xa5, 0xe5, 0x5d, 0x94, 0xe5, 0xbd, 0x33, 0x8b, 0x5a, 0x17, 0x77, 0xf3, 0x4b, 0xa8, 0xcf, 0x1f,
	0x7e, 0x09, 0xfa, 0xbb, 0x80, 0x26, 0xc4, 0x0e, 0x6e, 0x05, 0xaf, 0x0b, 0x4d, 0x0e, 0xfb, 0xaf,
	0x06, 0x94, 0x65, 0x35, 0x2e, 0x41, 0xfc, 0x2e, 0x98, 0x23, 0x1a, 0x39, 0x16, 0xe3, 0x36, 0x8f,
	0x59, 0x3a, 0x1d, 0x82, 0x10, 0x5e, 0x4a, 0x99, 0x30, 0x11, 0x6c, 0x74, 0x2c, 0x42, 0x69, 0x48,
	0xd3, 0x39, 0x11, 0xa4, 0xf0, 0x44, 0xc8, 0x12, 0x93, 0x04, 0x45, 0xcc, 0x50, 0x9b, 0x89, 0x89,
	0x46, 0x59, 0x94, 0x85, 0xf2, 0xc2, 0x2c, 0x6c, 0x00, 0xc8, 0x1d, 0xd5, 0x04, 0xfa, 0xcd, 0x9a,
	0xf8, 0x5c, 0x9f, 0x6b, 0xfb, 0xcf, 0xa1, 0xca, 0xc7, 0x34, 0xe4, 0xdc, 0x27, 0xba, 0x2a, 0xdf,
	0x5f, 0xe5, 0xcf, 0x49, 0xbb, 0xaf, 0x9d, 0x71, 0x0a, 0x83, 0xfa, 0x50, 0xe3, 0x84, 0x4e, 0xbc,
	0xc0, 0xe6, 0x49, 0xf3, 0x3c, 0x5d, 0x0d, 0x33, 0xf1, 0xc6, 0x33, 0xa0, 0xe6, 0xdf, 0x8b, 0x50,
	0x4d, 0x36, 0x5b, 0x92, 0x8d, 0x27, 0xb0, 0xe7, 0x86, 0xaf, 0x03, 0xfd, 0x4b, 0xcf, 0xf7, 0x26,
	0x62, 0x18, 0x8c, 0x54, 0x5a, 0xd6, 0x30, 0x9a, 0xe9, 0xce, 0x84, 0xaa, 0x1b, 0x31, 0x51, 0x11,
	0xe9, 0x2f, 0xc0, 0x99, 0x7d, 0x49, 0xda, 0xa7, 0xbf, 0xf5, 0x52, 0xeb, 0xa7, 0xf0, 0x30, 0x09,
	0xd4, 0xb2, 0x87, 0x9c, 0xd0, 0xb4, 0x86, 0x44, 0xca, 0x8c, 0x5e, 0x01, 0xef, 0x25, 0xfa, 0x43,
	0xa1, 0x4e, 0xa6, 0x89, 0x0e, 0xec, 0xcd, 0xf9, 0x0d, 0xa6, 0xe2, 0x33, 0xb3, 0xac, 0xbd, 0x50,
	0xce, 0xab, 0x3b, 0x55, 0xdf, 0x8f, 0x33, 0x9f, 0x61, 0x38, 0xdb, 0xa9, 0xb2, 0xe0, 0xe7, 0xc0,
	0x71, 0x18, 0x0f, 0x7c, 0xa2, 0x7e, 0x0e, 0xa4, 0x78, 0xcf, 0xc3, 0xe4, 0x0c, 0x72, 0x3e, 0xc9,
	0x9d, 0xa1, 0xf9, 0x2b, 0xa8, 0xa5, 0x64, 0x2f, 0x21, 0xf5, 0x29, 0x7c, 0x2b, 0x4d, 0xc4, 0x5c,
	0xd4, 0xaa, 0x73, 0x1e, 0xa4, 0xea, 0x6c, 0xd0, 0xdd, 0xea, 0x97, 0x15, 0x95, 0xe3, 0x41, 0x45,
	0x1e, 0xf2, 0xbd, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x6c, 0xc8, 0xca, 0xd0, 0x46, 0x16, 0x00,
	0x00,
}
