// Copyright 2016 IBM Corporation
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

package istio.proxy.v1alpha.config;
option go_package = "config";

// Glossary & concepts

// Service instances - set of pods/VMs/containers where the service is running.
// The members share one or more common attributes. For e.g., all pods in a
// group could share a common set of labels, or be running the same version of
// the application binary.

// Service variants - In a continuous deployment scenario, for a given service,
// there can be multiple sets of instances running potentially different
// *variants* of the application binary. These variants are not necessarily
// different API versions. They could be iterative changes to the same service,
// deployed in different environments (prod, staging, dev, etc.). Common
// scenarios where this occurs include A/B testing, canary rollouts, etc. The
// choice of a particular variant can be decided based on various criterion
// (headers, url, etc.) and/or by weights assigned to each variant.
// Each service has a default variant consisting of all its instances.

// Origin - client (browser or another service) calling the proxy/sidecar
// (typically to reach another service).

// Destination - The remote service to which the proxy/sidecar is talking to,
// on behalf of the origin service. There can be one or more variants for a
// given service (see the discussion on versions above). The proxy would choose
// the variant based on various routing rules.

// Applications address only the destination service using without knowledge of
// individual service variants. The actual choice of the variant is determined
// by the proxy, enabling the application code to decouple itself from the
// evolution of dependent services.

// Proxy level global configurations go here
message ProxyMeshConfig {
}

// Destination declares how to associate service instances with a service
// variant (through discovery or through static configuration), and policies
// that determine how to handle traffic (load balancing policies, failure
// recovery policies such as timeouts, retries, circuit breakers), etc.
// N.B.  The policies are enforced on egress connections or requests, i.e.,
// enforced when the origin service is opening a connection/sending a request
// via the proxy to the destination.
message Destination {
  // Service for which the service variant is defined.
  string destination = 1;

  // Identifier is the unique service variant name for a given service.
  // If left empty, the policies apply to the default service destination.
  google.protobuf.Struct identifier = 2;

  // Should be either http://.. or tcp://.. 
  LoadBalancing load_balancing = 3;
  Timeout timeout = 4;
  Retry retry = 5;
  CircuitBreaker circuit_breaker = 6;
  // TODO(rshriram, should be policy)
  // string health_check_endpoint = 3;
}

// TODO(rshriram): Since a Http request can match multiple route rules (e.g.,
// there are two routes for the prefix /foo, with differing Http match
// attributes such as Http headers), the first rule to match will/should be
// chosen by proxy implementations N.B.: When a request does not match any rule
// for Http, the downstream service would receive a HTTP 404

// Traffic routing related configurations for the proxy/sidecar.  The
// configuration generated for the proxy will preserve the order of rules
// specified by the user in the Istio config.  Requests can match either a L4
// or HTTP (L7) rule, but not both. A request can match multiple HTTP (L7)
// rules, but it can match only one L4 rule. This can be enforced by checking
// the match attributes. A HTTP match rule matches on both L4 and L7
// attributes, while a L4 rule matches based only on L4 attributes. Any
// duplication or collision in the match attributes between two L4 rules or
// between a L4 and L7 rule should throw an error.
message RouteRule {
  // Uniquely identifies the destination service (not its variants) associated
  // with this routing rule. This is applicable for host-based resolution in
  // HTTP as well as IP-based resolution in TCP.
  // *required*
  string destination = 1;

  // Set of conditions that must be satisfied, such as connection attributes,
  // protocol, request metadata, etc.
  MatchCondition match = 2;

  // Each routing rule is associated with one or more service variants, (see
  // glossary in beginning of document). Weights associated with the service
  // variant determine the proportion of traffic it receives.
  repeated DestinationWeight weights = 3;
}

message MatchCondition {
  // Identifies the service initiating a connection or a request.
  string origin = 1;

  // Identifies the origin service variant.
  google.protobuf.Struct origin_identifier = 2;

  oneof protocol {
    // Set of layer match attributes based on the IP ranges
    L4MatchAttributes tcp = 3;

    // Set of layer match attributes based on the IP ranges
    L4MatchAttributes udp = 4;

    // Set of HTTP request attributes in the match condition
    HTTPMatchAttributes http = 5;
  }
}

// L4 connection match attributes
message L4MatchAttributes {
  // IPv4 or IPv6 ip address with optional subnet. E.g., a.b.c.d/xx form or
  // just a.b.c.d
  repeated string origin_subnet = 1;

  // IPv4 or IPv6 ip address with optional subnet. E.g., a.b.c.d/xx form or
  // just a.b.c.d
  repeated string destination_subnet = 2;
}

// Http/1.1|Http/2|gRPC routing rule match criterion
message HTTPMatchAttributes {
  string scheme = 1;
  StringMatch authority = 2;
  StringMatch uri = 3;

  // Match Http requests based on the specified headers
  // Support exact/prefix/regex match on header values
  map<string, StringMatch> headers = 4;
}

// Each routing rule is associated with one or more service variants, (see
// glossary in beginning of document). Weights associated with the variant
// determine the proportion of traffic it receives.
message DestinationWeight {
  // Service variant destination identifier for the destination service.
  google.protobuf.Struct identifier = 1;

  // The proportion of traffic to be forwarded to the service variant Max is
  // 100. Sum of weights across variants should add up to 100.
  int32 weight = 2;
}

// Faults can be injected into the connections from downstream by the
// proxy, for testing the failure recovery capabilities of downstream
// services.  Faults include aborting the request/connection from
// downstream service, delaying the proxying of request/connection to the
// upstream service, and throttling the bandwidth of the connection
// (either end).

// TODO: This should be done on per-cluster basis.
// L4FaultInjection fault = 3;

// Faults can be injected into the API calls by the proxy, for
// testing the failure recovery capabilities of downstream services.
// Faults include aborting the Http request from downstream service,
// delaying the proxying of request to the upstream service, or both.
// TODO: This should move into UpstreamCluster
// HttpFaultInjection fault = 3;

// Describes how to matches a given string (exact match, prefix-based match
// or posix style regex based match). Match is case-sensitive.
message StringMatch {
  oneof match_type {
    string exact = 1;
    string prefix = 2;
    // posix style regex match. Throw error if user's chosen proxy does not
    // support posix regex.
    string regex = 3;
  }
}

// Load balancing policy to use when forwarding traffic.
message LoadBalancing {
  enum SimpleLBPolicy {
    // These four simple load balancing policies have literally no
    // additional configuration.
    ROUND_ROBIN = 0;
    LEAST_CONN = 1;
    IP_HASH = 2;
    RANDOM = 3;
  }
  oneof lb_policy {
    SimpleLBPolicy name = 1;
    //Custom policy implementations
    google.protobuf.Any custom_impl = 2;
  }
}

// Request timeout: wait time until a response is received. Does not
// indicate the time for the entire response to arrive. 
message Timeout {
  message SimpleTimeoutPolicy {
    // timeout is per attempt, when retries are specified as well.
    // seconds.nanoseconds format
    double timeout_seconds = 1;
    // Downstream service could specify timeout via Http header to the
    // proxy, if the proxy supports such a feature.
    string override_header_name = 2;
  }
  oneof timeout_policy {
    SimpleTimeoutPolicy simple_timeout = 1;
    // For proxies that support custom timeout policies
    google.protobuf.Any custom_impl = 2;
  }
}

// Retry policy to use when a request fails.
message Retry {
  message SimpleRetryPolicy {
    // number of times the request should be retried.
    // total timeout would be attempts * timeout
    uint32 attempts = 1;
    // Downstream Service could specify retry attempts via Http header to
    // the proxy, if the proxy supports such a feature.
    string override_header_name = 2;
  }
  oneof retry_policy {
    SimpleRetryPolicy simple_retry = 1;
    // For proxies that support custom retry policies
    google.protobuf.Any custom_impl = 2;
  }
}

// A minimal circuit breaker configuration.
message CircuitBreaker {
  message SimpleCircuitBreakerPolicy {
    // (for an unhealthy upstream) number of consecutive requests that
    // should succeed before the upstream is marked healthy.
    uint32 success_threshold = 1;

    // (for a healthy upstream) number of consecutive requests that
    // can fail before the upstream is marked unhealthy.
    uint32 failure_threshold = 2;

    // When a healthy upstream becomes unhealthy, duration to wait before
    // attempting to send requests to that upstream.
    // format seconds.nanoseconds
    double reset_timeout_seconds = 3;
  }
  oneof cb_policy {
    SimpleCircuitBreakerPolicy simple_cb = 1;
    // For proxies that support custom circuit breaker policies.
    google.protobuf.Any custom_impl = 2;
  }
}

// Faults can be injected into the API calls by the proxy, for testing the
// failure recovery capabilities of downstream services.  Faults include
// aborting the Http request from downstream service, delaying the proxying of
// requests, or both.
message HttpFaultInjection {
  // Delay requests before forwarding, emulating various failures such as
  // network issues, overloaded upstream service, etc.
  Delay delay = 1;

  // Abort Http request attempts and return error codes back to downstream
  // service, giving the impression that the upstream service is faulty.
  // N.B. Both delay and abort can be specified simultaneously. Delay and
  // Abort are independent of one another. For e.g., if Delay is restricted
  // to 5% of requests while Abort is restricted to 10% of requests, the
  // 10% in abort specification applies to all requests directed to the
  // service. It may be the case that one or more requests being aborted
  // were also delayed.
  Abort abort = 2;

  // Only requests with these Http headers will be subjected to fault
  // injection
  map<string, StringMatch> headers = 3;

  // Either a fixed delay or exponential delay.
  message Delay {
    oneof http_delay_type {
      FixedDelay fixed_delay = 1;
      ExponentialDelay exp_delay = 2;
    }
    // Specify delay duration as part of Http request.
    // TODO: The semantics and syntax of the headers is undefined.
    string override_header_name = 3;
  }

  // Add a fixed delay before forwarding the request
  message FixedDelay {
    // percentage of requests on which the delay will be injected
    float percent = 1;
    // delay duration in seconds.nanoseconds
    double fixed_delay_seconds = 2;
  }

  // Add a delay (based on an exponential function) before forwarding the
  // request
  message ExponentialDelay {
    // percentage of requests on which the delay will be injected
    float percent = 1;
    // mean delay needed to derive the exponential delay values
    double mean_delay_seconds = 2;
  }

  // Abort Http request attempts and return error codes back to downstream
  // service.
  message Abort {
    // percentage of requests to be aborted with the error code provided.
    float percent = 1;
    // Error code to use to abort the Http request. Requests can be aborted
    // either with Http/1.1 status codes | http2 error codes or gRPC status
    // codes.
    oneof error_type {
      string grpc_status = 2;
      string http2_error = 3;
      uint32 http_status = 4;
    }
    // Specify abort code as part of Http request.
    // TODO: The semantics and syntax of the headers is undefined.
    string override_header_name = 5;
  }
}

// Faults can be injected into the L4 traffic forwarded by the proxy, for
// testing the failure recovery capabilities of downstream services.
// Faults include terminating established Tcp connections, throttling the
// upstream/downstream bandwidth (for Tcp|Udp), or both.
message L4FaultInjection {
  // Unlike Http services, we have very little context for raw Tcp|Udp
  // connections. We could throttle bandwidth of the connections (slow down
  // the connection) and/or abruptly reset (terminate) the Tcp connection
  // after it has been established.

  // We first throttle (if set) and then terminate the connection.
  Throttle throttle = 1;
  Terminate terminate = 2;

 // Bandwidth throttling for Tcp and Udp connections
  message Throttle {
    // percentage of connections to throttle.
    float percent = 1;
    // bandwidth limit in "bits" per second between downstream and proxy
    uint64 downstream_limit_bps = 2;
    // bandwidth limits in "bits" per second between proxy and upstream
    uint64 upstream_limit_bps = 3;

    oneof throttle_after {
      // Wait for X seconds after the connection is established, before
      // starting bandwidth throttling. This would allow us to inject fault
      // after the application protocol (e.g., MySQL) has had time to
      // establish sessions/whatever handshake necessary.
      double throttle_after_seconds = 4;

      // Alternatively, we could wait for a certain number of bytes to be
      // transferred to upstream before throttling the bandwidth.
      double throttle_after_bytes = 5;
    }

    // Stop throttling after the given duration. If not set, the connection
    // will be throttled for its lifetime.
    google.protobuf.DoubleValue throttle_for_seconds = 6;
  }

  // Abruptly reset (terminate) the Tcp connection after it has been
  // established, emulating remote server crash or link failure.
  message Terminate {
    // percentage of established Tcp connections to be terminated/reset
    float percent = 1;

    // Wait for X seconds after the connection is established, before
    // terminating the connection. Set to 0 to terminate immediately on
    // connection establishment.

    // TODO: see if it makes sense to create a generic Duration type to
    // express time interval related configs.
    double terminate_after_seconds = 2;
  }
}
