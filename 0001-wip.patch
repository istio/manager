From d2031395de9de8d86346bb6e90ecc864587c704c Mon Sep 17 00:00:00 2001
From: Jason Young <jasonyoung@google.com>
Date: Wed, 8 Mar 2017 11:38:59 -0800
Subject: [PATCH] wip

---
 .gitignore                 |   1 +
 WORKSPACE                  |  12 ++
 bin/check.sh               |   5 +-
 bin/codecov.sh             |   3 +-
 bin/init.sh                |   3 +
 model/.gitignore           |   1 +
 model/BUILD                |  24 +++
 model/config.go            |  84 ++++++--
 model/config_test.go       | 469 ++++++++++++++++++++++++++++++++++++++++++++-
 model/service.go           | 169 ++++++++++++----
 model/validation.go        | 163 ----------------
 model/validation_test.go   |  15 ++
 proxy/envoy/BUILD          |   1 +
 proxy/envoy/config_test.go |  21 +-
 14 files changed, 744 insertions(+), 227 deletions(-)
 create mode 100644 model/.gitignore
 create mode 100644 model/validation_test.go

diff --git a/.gitignore b/.gitignore
index 0810316..a652883 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,3 +6,4 @@ vendor
 *.iml
 echo.yaml
 .vagrant
+coverage.out
diff --git a/WORKSPACE b/WORKSPACE
index bdba577..f630925 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -268,6 +268,18 @@ new_go_repository(
     importpath = "k8s.io/client-go",
 )
 
+new_go_repository(
+    name = "com_github_golang_mock",
+    commit = "bd3c8e81be01eef76d4b503f5e687d2d1354d2d9",
+    importpath = "github.com/golang/mock",
+)
+
+new_go_repository(
+    name = "com_github_davecgh_gospew_spew",
+    commit = "346938d642f2ec3594ed81d874461961cd0faa76", # v1.1.0
+    importpath = "github.com/davecgh/go-spew/spew",
+)
+
 ##
 ## Proxy build rules
 ##
diff --git a/bin/check.sh b/bin/check.sh
index d5d98c1..ed48c23 100755
--- a/bin/check.sh
+++ b/bin/check.sh
@@ -3,6 +3,8 @@ set -ex
 
 buildifier -showlog -mode=check $(find . -type f \( -name 'BUILD' -or -name 'WORKSPACE' -or -wholename '.*bazel' -or -wholename '.*bzl' \) -print )
 
+go generate ./...
+
 gometalinter --concurrency=4 --enable-gc --deadline=300s --disable-all\
   --enable=aligncheck\
   --enable=deadcode\
@@ -11,7 +13,8 @@ gometalinter --concurrency=4 --enable-gc --deadline=300s --disable-all\
   --enable=goconst\
   --enable=gofmt\
   --enable=goimports\
-  --enable=golint --exclude=.pb.go\
+  --enable=golint\
+  --exclude=.pb.go\
   --enable=gosimple\
   --enable=gotype\
   --enable=ineffassign\
diff --git a/bin/codecov.sh b/bin/codecov.sh
index 7254434..9fc8fa6 100755
--- a/bin/codecov.sh
+++ b/bin/codecov.sh
@@ -4,7 +4,7 @@ set -e
 echo "" > coverage.txt
 
 for d in $(go list ./... | grep -v vendor); do
-    options="-coverprofile=profile.out -covermode=atomic"
+    options="-coverprofile=profile.out -covermode=set"
     case $d in
         istio.io/manager/platform/kube)
             echo "Skipping race detection on $d (see https://github.com/istio/manager/issues/173)"
@@ -13,6 +13,7 @@ for d in $(go list ./... | grep -v vendor); do
             options=$options" -race"
             ;;
     esac
+    go generate $d
     go test $options $d
 
     if [ -f profile.out ]; then
diff --git a/bin/init.sh b/bin/init.sh
index fcdc601..d798057 100755
--- a/bin/init.sh
+++ b/bin/init.sh
@@ -7,6 +7,9 @@ bin/bazel_to_go.py > /dev/null
 # Remove doubly-vendorized k8s dependencies
 rm -rf vendor/k8s.io/client-go/vendor
 
+# Install mockgen tool to generate golang mock interfaces
+go get github.com/golang/mock/mockgen
+
 go install ./...
 go get -u github.com/alecthomas/gometalinter
 go get -u github.com/bazelbuild/buildifier/buildifier
diff --git a/model/.gitignore b/model/.gitignore
new file mode 100644
index 0000000..b5dc53a
--- /dev/null
+++ b/model/.gitignore
@@ -0,0 +1 @@
+mock_config_test.go
diff --git a/model/BUILD b/model/BUILD
index c2c39fc..495ac17 100644
--- a/model/BUILD
+++ b/model/BUILD
@@ -14,18 +14,42 @@ go_library(
         "//model/proxy/alphav1/config:go_default_library",
         "@com_github_ghodss_yaml//:go_default_library",
         "@com_github_golang_glog//:go_default_library",
+        "@com_github_golang_mock//gomock:go_default_library",
         "@com_github_golang_protobuf//jsonpb:go_default_library",
         "@com_github_golang_protobuf//proto:go_default_library",
         "@com_github_hashicorp_go_multierror//:go_default_library",
     ],
 )
 
+# Auto-generate mock interfaces for unit testing model package.
+#
+# This should be kept in sync with the `go:generate` directive at the
+# top of config_test.go which is necessary for non-bazel testing with
+# `go test`.
+#
+# Add `_test` suffix to the output file so mock interfaces, functions,
+# etc. are excluded from test coverage, gometalinter, etc.
+genrule(
+    name = "genmocks",
+    srcs = ["config.go"],
+    outs = ["mock_config_test.go"],
+    cmd = " mockgen -source $< -destination $@ -package model",
+)
+
 go_test(
     name = "go_default_test",
     size = "small",
     srcs = [
         "config_test.go",
         "service_test.go",
+        "validation_test.go",
+        "mock_config_test.go",
     ],
+    data = [":genmocks"],
     library = ":go_default_library",
+    deps = [
+        "//model/proxy/alphav1/config:go_default_library",
+        "@com_github_golang_protobuf//proto:go_default_library",
+        "@com_github_davecgh_go_spew//spew:go_default_library",
+    ],
 )
diff --git a/model/config.go b/model/config.go
index 5ebe0f8..59c610a 100644
--- a/model/config.go
+++ b/model/config.go
@@ -16,11 +16,11 @@ package model
 
 import (
 	"fmt"
-	"io/ioutil"
 	"sort"
 
 	"github.com/golang/glog"
 	"github.com/golang/protobuf/proto"
+	multierror "github.com/hashicorp/go-multierror"
 
 	proxyconfig "istio.io/manager/model/proxy/alphav1/config"
 )
@@ -96,6 +96,75 @@ type ProtoSchema struct {
 	Internal bool
 }
 
+// Validate confirms that the names in the configuration key are appropriate
+func (k *Key) Validate() error {
+	var errs error
+	if !IsDNS1123Label(k.Kind) {
+		errs = multierror.Append(errs, fmt.Errorf("Invalid kind: %q", k.Kind))
+	}
+	if !IsDNS1123Label(k.Name) {
+		errs = multierror.Append(errs, fmt.Errorf("Invalid name: %q", k.Name))
+	}
+	if !IsDNS1123Label(k.Namespace) {
+		errs = multierror.Append(errs, fmt.Errorf("Invalid namespace: %q", k.Namespace))
+	}
+	return errs
+}
+
+// Validate checks that each name conforms to the spec and has a ProtoMessage
+func (km KindMap) Validate() error {
+	var errs error
+	for k, v := range km {
+		if !IsDNS1123Label(k) {
+			errs = multierror.Append(errs, fmt.Errorf("Invalid kind: %q", k))
+		}
+		if proto.MessageType(v.MessageName) == nil {
+			errs = multierror.Append(errs, fmt.Errorf("Cannot find proto message type: %q", v.MessageName))
+		}
+	}
+	return errs
+}
+
+// ValidateKey ensures that the key is well-defined and kind is well-defined
+func (km KindMap) ValidateKey(k *Key) error {
+	if err := k.Validate(); err != nil {
+		return err
+	}
+	if _, ok := km[k.Kind]; !ok {
+		return fmt.Errorf("Kind %q is not defined", k.Kind)
+	}
+	return nil
+}
+
+// ValidateConfig ensures that the config object is well-defined
+func (km KindMap) ValidateConfig(k *Key, obj interface{}) error {
+	if k == nil || obj == nil {
+		return fmt.Errorf("Invalid nil configuration object")
+	}
+
+	if err := k.Validate(); err != nil {
+		return err
+	}
+	t, ok := km[k.Kind]
+	if !ok {
+		return fmt.Errorf("Undeclared kind: %q", k.Kind)
+	}
+
+	v, ok := obj.(proto.Message)
+	if !ok {
+		return fmt.Errorf("Cannot cast to a proto message")
+	}
+	if proto.MessageName(v) != t.MessageName {
+		return fmt.Errorf("Mismatched message type %q and kind %q",
+			proto.MessageName(v), t.MessageName)
+	}
+	if err := t.Validate(v); err != nil {
+		return err
+	}
+
+	return nil
+}
+
 // Kinds lists all kinds in the kind schemas
 func (km KindMap) Kinds() []string {
 	kinds := make([]string, 0)
@@ -106,19 +175,6 @@ func (km KindMap) Kinds() []string {
 	return kinds
 }
 
-// FromYAML reads object contents from a file
-func (km KindMap) FromYAML(kind, file string) (proto.Message, error) {
-	schema, ok := km[kind]
-	if !ok {
-		return nil, fmt.Errorf("Missing kind %q", kind)
-	}
-	content, err := ioutil.ReadFile(file)
-	if err != nil {
-		return nil, err
-	}
-	return schema.FromYAML(string(content))
-}
-
 const (
 	// RouteRule defines the kind for the route rule configuration
 	RouteRule = "route-rule"
diff --git a/model/config_test.go b/model/config_test.go
index a0a293f..5ac67a0 100644
--- a/model/config_test.go
+++ b/model/config_test.go
@@ -1,3 +1,6 @@
+// Keep this in sync with the `//model:genmock` build target.
+//go:generate mockgen -source config.go -destination mock_config_test.go -package model
+
 // Copyright 2017 Istio Authors
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +17,18 @@
 
 package model
 
-import "testing"
+import (
+	"errors"
+	"reflect"
+	"strings"
+	"testing"
+
+	"github.com/davecgh/go-spew/spew"
+	"github.com/golang/mock/gomock"
+	"github.com/golang/protobuf/proto"
+
+	proxyconfig "istio.io/manager/model/proxy/alphav1/config"
+)
 
 var (
 	validKeys = []Key{
@@ -30,7 +44,7 @@ var (
 	}
 )
 
-func TestConfigValidation(t *testing.T) {
+func TestKeyValidate(t *testing.T) {
 	for _, valid := range validKeys {
 		if err := valid.Validate(); err != nil {
 			t.Errorf("Valid config failed validation: %#v", valid)
@@ -38,14 +52,455 @@ func TestConfigValidation(t *testing.T) {
 	}
 	for _, invalid := range invalidKeys {
 		if err := invalid.Validate(); err == nil {
-			t.Errorf("Inalid config passed validation: %#v", invalid)
+			t.Errorf("Invalid config passed validation: %#v", invalid)
+		}
+	}
+}
+
+func TestKindMapValidate(t *testing.T) {
+	badLabel := strings.Repeat("a", dns1123LabelMaxLength+1)
+	goodLabel := strings.Repeat("a", dns1123LabelMaxLength-1)
+
+	cases := []struct {
+		name    string
+		kindMap KindMap
+		wantErr bool
+	}{{
+		name:    "Valid KindMap (IstioConfig)",
+		kindMap: IstioConfig,
+		wantErr: false,
+	}, {
+		name:    "Invalid DNS11234Label in KindMap",
+		kindMap: KindMap{badLabel: ProtoSchema{}},
+		wantErr: true,
+	}, {
+		name:    "Bad MessageName in ProtoMessage",
+		kindMap: KindMap{goodLabel: ProtoSchema{}},
+		wantErr: true,
+	}}
+
+	for _, c := range cases {
+		if err := c.kindMap.Validate(); (err != nil) != c.wantErr {
+			t.Errorf("%v failed: got %v but wantErr=%v", c.name, err, c.wantErr)
+		}
+	}
+}
+
+func TestKindMapValidKey(t *testing.T) {
+	cases := []struct {
+		name    string
+		key     Key
+		kindMap KindMap
+		wantErr bool
+	}{
+		{
+			name:    "Valid key that exists in KindMap",
+			key:     validKeys[0],
+			kindMap: KindMap{validKeys[0].Kind: ProtoSchema{}},
+			wantErr: false,
+		},
+		{
+			name:    "Valid key that doesn't exists in KindMap",
+			key:     validKeys[0],
+			kindMap: KindMap{},
+			wantErr: true,
+		},
+		{
+			name:    "InvValid key that exists in KindMap",
+			key:     invalidKeys[0],
+			kindMap: KindMap{validKeys[0].Kind: ProtoSchema{}},
+			wantErr: true,
+		},
+		{
+			name:    "Invalid key that doesn't exists in KindMap",
+			key:     invalidKeys[0],
+			kindMap: KindMap{},
+			wantErr: true,
+		},
+	}
+	for _, c := range cases {
+		if err := c.kindMap.ValidateKey(&c.key); (err != nil) != c.wantErr {
+			t.Errorf("%v  failed got error=%v but wantErr=%v", c.name, err, c.wantErr)
+		}
+	}
+}
+
+func TestKindMapValidateConfig(t *testing.T) {
+	cases := []struct {
+		name    string
+		key     *Key
+		config  interface{}
+		wantErr bool
+	}{
+		{
+			name:    "bad key",
+			key:     nil,
+			config:  &proxyconfig.RouteRule{},
+			wantErr: true,
+		},
+		{
+			name:    "bad configuration object",
+			key:     &validKeys[0],
+			config:  nil,
+			wantErr: true,
+		},
+		{
+			name:    "invalid key",
+			key:     &invalidKeys[0],
+			config:  &proxyconfig.RouteRule{},
+			wantErr: true,
+		},
+		{
+			name:    "undeclared kind",
+			key:     &validKeys[0],
+			config:  &proxyconfig.RouteRule{},
+			wantErr: true,
+		},
+		{
+			name: "non-proto object configuration",
+			key: &Key{
+				Kind:      RouteRule,
+				Name:      "foo",
+				Namespace: "bar",
+			},
+			config:  "non-proto objection configuration",
+			wantErr: true,
+		},
+		{
+			name: "message type and kind mismatch",
+			key: &Key{
+				Kind:      RouteRule,
+				Name:      "foo",
+				Namespace: "bar",
+			},
+			config: &proxyconfig.DestinationPolicy{
+				Destination: "foo",
+			},
+			wantErr: true,
+		},
+		{
+			name: "ProtoSchema validation",
+			key: &Key{
+				Kind:      RouteRule,
+				Name:      "foo",
+				Namespace: "bar",
+			},
+			config:  &proxyconfig.RouteRule{},
+			wantErr: true,
+		},
+		{
+			name: "ProtoSchema validation",
+			key: &Key{
+				Kind:      RouteRule,
+				Name:      "foo",
+				Namespace: "bar",
+			},
+			config: &proxyconfig.RouteRule{
+				Destination: "foo",
+			},
+			wantErr: false,
+		},
+	}
+
+	for _, c := range cases {
+		if err := IstioConfig.ValidateConfig(c.key, c.config); (err != nil) != c.wantErr {
+			t.Errorf("%v failed: got error=%v but wantErr=%v", c.name, err, c.wantErr)
+		}
+	}
+}
+
+func TestKindMapKinds(t *testing.T) {
+	km := KindMap{
+		"b": ProtoSchema{},
+		"a": ProtoSchema{},
+		"c": ProtoSchema{},
+	}
+	want := []string{"a", "b", "c"}
+	got := km.Kinds()
+	if !reflect.DeepEqual(got, want) {
+		t.Errorf("KindMap.Kinds failed: \tgot %v want %v", got, want)
+	}
+}
+
+type testRegistry struct {
+	ctrl     gomock.Controller
+	mock     *MockConfigRegistry
+	registry IstioRegistry
+}
+
+func initTestRegistry(t *testing.T) *testRegistry {
+	ctrl := gomock.NewController(t)
+	mock := NewMockConfigRegistry(ctrl)
+	return &testRegistry{
+		mock: mock,
+		registry: IstioRegistry{
+			ConfigRegistry: mock,
+		},
+	}
+}
+
+func (r *testRegistry) shutdown() {
+	r.ctrl.Finish()
+}
+
+var (
+	defaultNamespace = "default"
+
+	serviceInstance1 = &ServiceInstance{
+		Endpoint: NetworkEndpoint{
+			Address:     "192.168.1.1",
+			Port:        10001,
+			ServicePort: &Port{Name: "http", Port: 81, Protocol: ProtocolHTTP},
+		},
+		Service: &Service{
+			Hostname: "one.service.com",
+			Address:  "192.168.3.1", // VIP
+			Ports: PortList{
+				&Port{Name: "http", Port: 81, Protocol: ProtocolHTTP},
+				&Port{Name: "http-alt", Port: 8081, Protocol: ProtocolHTTP},
+			},
+		},
+		Tags: Tags{"a": "b", "c": "d"},
+	}
+	serviceInstance2 = &ServiceInstance{
+		Endpoint: NetworkEndpoint{
+			Address:     "192.168.1.2",
+			Port:        10002,
+			ServicePort: &Port{Name: "http", Port: 82, Protocol: ProtocolHTTP},
+		},
+		Service: &Service{
+			Hostname: "two.service.com",
+			Address:  "192.168.3.2", // VIP
+			Ports: PortList{
+				&Port{Name: "http", Port: 82, Protocol: ProtocolHTTP},
+				&Port{Name: "http-alt", Port: 8282, Protocol: ProtocolHTTP},
+			},
+		},
+		Tags: Tags{"e": "f", "g": "h"},
+	}
+
+	routeRule1MatchNil = &proxyconfig.RouteRule{
+		Destination: "foo",
+		Precedence:  1,
+	}
+
+	routeRule2SourceEmpty = &proxyconfig.RouteRule{
+		Destination: "foo",
+		Precedence:  2,
+		Match:       &proxyconfig.MatchCondition{},
+	}
+	routeRule3SourceMismatch = &proxyconfig.RouteRule{
+		Destination: "foo",
+		Precedence:  3,
+		Match: &proxyconfig.MatchCondition{
+			Source: "three.service.com",
+		},
+	}
+	routeRule4SourceMatch = &proxyconfig.RouteRule{
+		Destination: "foo",
+		Precedence:  4,
+		Match: &proxyconfig.MatchCondition{
+			Source: "one.service.com",
+		},
+	}
+	routeRule5TagSubsetOfMismatch = &proxyconfig.RouteRule{
+		Destination: "foo",
+		Precedence:  5,
+		Match: &proxyconfig.MatchCondition{
+			Source:     "two.service.com",
+			SourceTags: map[string]string{"z": "y"},
+		},
+	}
+	routeRule6TagSubsetOfMatch = &proxyconfig.RouteRule{
+		Destination: "foo",
+		Precedence:  5,
+		Match: &proxyconfig.MatchCondition{
+			Source:     "one.service.com",
+			SourceTags: map[string]string{"a": "b"},
+		},
+	}
+
+	dstTags0 = map[string]string{"a": "b"}
+	dstTags1 = map[string]string{"c": "d"}
+	dstTags2 = map[string]string{"e": "f"}
+
+	dstPolicy1 = &proxyconfig.DestinationPolicy{
+		Destination: "foo",
+		Tags:        dstTags0,
+	}
+	dstPolicy2 = &proxyconfig.DestinationPolicy{
+		Destination: "foo",
+	}
+	dstPolicy3 = &proxyconfig.DestinationPolicy{
+		Destination: "bar",
+		Tags:        dstTags1,
+	}
+	dstPolicy4 = &proxyconfig.DestinationPolicy{
+		Destination: "baz",
+		Tags:        dstTags2,
+	}
+)
+
+func TestIstioRegistryRouteAndIngressRules(t *testing.T) {
+	r := initTestRegistry(t)
+	defer r.shutdown()
+
+	cases := []struct {
+		name      string
+		mockError error
+		mockObjs  map[Key]proto.Message
+		want      []*proxyconfig.RouteRule
+	}{
+		{
+			name:      "Empty object map with error",
+			mockObjs:  map[Key]proto.Message{},
+			mockError: errors.New("foobar"),
+			want:      []*proxyconfig.RouteRule{},
+		},
+		{
+			name: "Slice of unsorted RouteRules",
+			mockObjs: map[Key]proto.Message{
+				Key{Kind: "foo"}: routeRule1MatchNil,
+				Key{Kind: "bar"}: routeRule3SourceMismatch,
+				Key{Kind: "baz"}: routeRule2SourceEmpty,
+			},
+			want: []*proxyconfig.RouteRule{
+				routeRule1MatchNil,
+				routeRule3SourceMismatch,
+				routeRule2SourceEmpty,
+			},
+		},
+	}
+	makeSet := func(in []*proxyconfig.RouteRule) map[*proxyconfig.RouteRule]struct{} {
+		out := map[*proxyconfig.RouteRule]struct{}{}
+		for _, c := range in {
+			out[c] = struct{}{}
+		}
+		return out
+	}
+
+	for _, c := range cases {
+		// Use sets to compare unsorted route rules.
+
+		r.mock.EXPECT().List(RouteRule, defaultNamespace).Return(c.mockObjs, c.mockError)
+		if got := r.registry.RouteRules(defaultNamespace); !reflect.DeepEqual(makeSet(got), makeSet(c.want)) {
+			t.Errorf("%v with RouteRule failed: \ngot %+vwant %+v", c.name, spew.Sdump(got), spew.Sdump(c.want))
+		}
+
+		r.mock.EXPECT().List(IngressRule, defaultNamespace).Return(c.mockObjs, c.mockError)
+		if got := r.registry.IngressRules(defaultNamespace); !reflect.DeepEqual(makeSet(got), makeSet(c.want)) {
+			t.Errorf("%v with IngressRule failed: \ngot %+vwant %+v", c.name, spew.Sdump(got), spew.Sdump(c.want))
+		}
+	}
+}
+
+func TestIstioRegistryRouteRulesBySource(t *testing.T) {
+	r := initTestRegistry(t)
+	defer r.shutdown()
+
+	instances := []*ServiceInstance{serviceInstance1, serviceInstance2}
+
+	mockObjs := map[Key]proto.Message{
+		Key{Kind: "match-nil"}:              routeRule1MatchNil,
+		Key{Kind: "source-empty"}:           routeRule2SourceEmpty,
+		Key{Kind: "source-mismatch"}:        routeRule3SourceMismatch,
+		Key{Kind: "source-match"}:           routeRule4SourceMatch,
+		Key{Kind: "tag-subset-of-mismatch"}: routeRule5TagSubsetOfMismatch,
+		Key{Kind: "tag-subset-of-match"}:    routeRule6TagSubsetOfMatch,
+	}
+	want := []*proxyconfig.RouteRule{
+		routeRule6TagSubsetOfMatch,
+		routeRule4SourceMatch,
+		routeRule2SourceEmpty,
+		routeRule1MatchNil,
+	}
+
+	r.mock.EXPECT().List(RouteRule, defaultNamespace).Return(mockObjs, nil)
+	got := r.registry.RouteRulesBySource(defaultNamespace, instances)
+	if !reflect.DeepEqual(got, want) {
+		t.Errorf("Failed \ngot %+vwant %+v", spew.Sdump(got), spew.Sdump(want))
+	}
+}
+
+func TestIstioRegistryPoliciesByNamespace(t *testing.T) {
+	r := initTestRegistry(t)
+	defer r.shutdown()
+
+	cases := []struct {
+		name      string
+		mockError error
+		mockObjs  map[Key]proto.Message
+		want      []*proxyconfig.DestinationPolicy
+	}{
+		{
+			name:      "Empty object map with error",
+			mockObjs:  map[Key]proto.Message{},
+			mockError: errors.New("foobar"),
+			want:      []*proxyconfig.DestinationPolicy{},
+		},
+		{
+			name: "Slice of unsorted DestinationPolicy",
+			mockObjs: map[Key]proto.Message{
+				Key{Kind: "foo"}: dstPolicy1,
+				Key{Kind: "bar"}: dstPolicy2,
+				Key{Kind: "baz"}: dstPolicy3,
+			},
+			want: []*proxyconfig.DestinationPolicy{
+				dstPolicy1, dstPolicy2, dstPolicy3,
+			},
+		},
+	}
+	makeSet := func(in []*proxyconfig.DestinationPolicy) map[*proxyconfig.DestinationPolicy]struct{} {
+		out := map[*proxyconfig.DestinationPolicy]struct{}{}
+		for _, c := range in {
+			out[c] = struct{}{}
+		}
+		return out
+	}
+
+	for _, c := range cases {
+		r.mock.EXPECT().List(DestinationPolicy, defaultNamespace).Return(c.mockObjs, c.mockError)
+		if got := r.registry.PoliciesByNamespace(defaultNamespace); !reflect.DeepEqual(makeSet(got), makeSet(c.want)) {
+			t.Errorf("%v failed: \ngot %+vwant %+v", c.name, spew.Sdump(got), spew.Sdump(c.want))
 		}
 	}
 }
 
-func TestConfigKinds(t *testing.T) {
-	err := IstioConfig.Validate()
-	if err != nil {
-		t.Errorf(err.Error())
+func TestIstioRegistryDestinationPolicies(t *testing.T) {
+	r := initTestRegistry(t)
+	defer r.shutdown()
+
+	mockObjs := map[Key]proto.Message{
+		Key{Kind: "foo"}:  dstPolicy1,
+		Key{Kind: "foo2"}: dstPolicy2,
+		Key{Kind: "bar"}:  dstPolicy3,
+		Key{Kind: "baz"}:  dstPolicy4,
+	}
+	want := []*proxyconfig.DestinationPolicy{
+		dstPolicy1,
+	}
+
+	r.mock.EXPECT().List(DestinationPolicy, "").Return(mockObjs, nil)
+	if got := r.registry.DestinationPolicies(dstPolicy1.Destination, dstPolicy1.Tags); !reflect.DeepEqual(got, want) {
+		t.Errorf("Failed: \ngot %+vwant %+v", spew.Sdump(got), spew.Sdump(want))
+	}
+}
+
+func TestRouteRulePrcedence(t *testing.T) {
+
+}
+
+func TestKeyString(t *testing.T) {
+	cases := []struct {
+		in   Key
+		want string
+	}{{
+		in:   Key{Kind: "ExampleKind", Name: "x", Namespace: "default"},
+		want: "default/ExampleKind-x",
+	}}
+	for _, c := range cases {
+		if c.in.String() != c.want {
+			t.Errorf("Bad human-readable string: got %v want %v", c.in.String(), c.want)
+		}
 	}
 }
diff --git a/model/service.go b/model/service.go
index fda0089..4d76ba0 100644
--- a/model/service.go
+++ b/model/service.go
@@ -27,6 +27,8 @@ import (
 	"fmt"
 	"sort"
 	"strings"
+
+	multierror "github.com/hashicorp/go-multierror"
 )
 
 // Service describes an Istio service (e.g., catalog.mystore.com:8080)
@@ -200,6 +202,61 @@ func (t Tags) Equals(that Tags) bool {
 	return t.SubsetOf(that) && that.SubsetOf(t)
 }
 
+func (t Tags) String() string {
+	labels := make([]string, 0)
+	for k, v := range t {
+		if len(v) > 0 {
+			labels = append(labels, fmt.Sprintf("%s=%s", k, v))
+		} else {
+			labels = append(labels, k)
+		}
+	}
+	sort.Strings(labels)
+
+	var buffer bytes.Buffer
+	var first = true
+	for _, label := range labels {
+		if !first {
+			buffer.WriteString(",")
+		} else {
+			first = false
+		}
+		buffer.WriteString(label)
+	}
+	return buffer.String()
+}
+
+// Validate ensures tag is well-formed
+func (t Tags) Validate() error {
+	var errs error
+	if len(t) == 0 {
+		errs = multierror.Append(errs, fmt.Errorf("Tag must have at least one key-value pair"))
+	}
+	for k, v := range t {
+		if !tagRegexp.MatchString(k) {
+			errs = multierror.Append(errs, fmt.Errorf("Invalid tag key: %q", k))
+		}
+		if !tagRegexp.MatchString(v) {
+			errs = multierror.Append(errs, fmt.Errorf("Invalid tag value: %q", v))
+		}
+	}
+	return errs
+}
+
+// ParseTagString extracts tags from a string
+func ParseTagString(s string) Tags {
+	tag := make(map[string]string)
+	for _, pair := range strings.Split(s, ",") {
+		kv := strings.Split(pair, "=")
+		if len(kv) > 1 {
+			tag[kv[0]] = kv[1]
+		} else {
+			tag[kv[0]] = ""
+		}
+	}
+	return tag
+}
+
 // HasSubsetOf returns true if the input tags are a super set of one tags in a
 // collection or if the tag collection is empty
 func (tags TagsList) HasSubsetOf(that Tags) bool {
@@ -239,6 +296,80 @@ func (s *Service) Key(port *Port, tag Tags) string {
 	return ServiceKey(s.Hostname, PortList{port}, TagsList{tag})
 }
 
+// Validate ensures that the service object is well-defined
+func (s *Service) Validate() error {
+	var errs error
+	if len(s.Hostname) == 0 {
+		errs = multierror.Append(errs, fmt.Errorf("Invalid empty hostname"))
+	}
+	parts := strings.Split(s.Hostname, ".")
+	for _, part := range parts {
+		if !IsDNS1123Label(part) {
+			errs = multierror.Append(errs, fmt.Errorf("Invalid hostname part: %q", part))
+		}
+	}
+
+	// Require at least one port
+	if len(s.Ports) == 0 {
+		errs = multierror.Append(errs, fmt.Errorf("Service must have at least one declared port"))
+	}
+
+	// Port names can be empty if there exists only one port
+	for _, port := range s.Ports {
+		if port.Name == "" {
+			if len(s.Ports) > 1 {
+				errs = multierror.Append(errs,
+					fmt.Errorf("Empty port names are not allowed for services with multiple ports"))
+			}
+		} else if !IsDNS1123Label(port.Name) {
+			errs = multierror.Append(errs, fmt.Errorf("Invalid name: %q", port.Name))
+		}
+		if port.Port < 0 {
+			errs = multierror.Append(errs, fmt.Errorf("Invalid service port value %d for %q", port.Port, port.Name))
+		}
+	}
+	return errs
+}
+
+// Validate ensures that the service instance is well-defined
+func (instance *ServiceInstance) Validate() error {
+	var errs error
+	if instance.Service == nil {
+		errs = multierror.Append(errs, fmt.Errorf("Missing service in the instance"))
+	} else if err := instance.Service.Validate(); err != nil {
+		errs = multierror.Append(errs, err)
+	}
+
+	if err := instance.Tags.Validate(); err != nil {
+		errs = multierror.Append(errs, err)
+	}
+
+	if instance.Endpoint.Port < 0 {
+		errs = multierror.Append(errs, fmt.Errorf("Negative port value: %d", instance.Endpoint.Port))
+	}
+
+	port := instance.Endpoint.ServicePort
+	if port == nil {
+		errs = multierror.Append(errs, fmt.Errorf("Missing service port"))
+	} else if instance.Service != nil {
+		expected, ok := instance.Service.Ports.Get(port.Name)
+		if !ok {
+			errs = multierror.Append(errs, fmt.Errorf("Missing service port %q", port.Name))
+		} else {
+			if expected.Port != port.Port {
+				errs = multierror.Append(errs,
+					fmt.Errorf("Unexpected service port value %d, expected %d", port.Port, expected.Port))
+			}
+			if expected.Protocol != port.Protocol {
+				errs = multierror.Append(errs,
+					fmt.Errorf("Unexpected service protocol %s, expected %s", port.Protocol, expected.Protocol))
+			}
+		}
+	}
+
+	return errs
+}
+
 // ServiceKey generates a service key for a collection of ports and tags
 func ServiceKey(hostname string, servicePorts PortList, serviceTags TagsList) string {
 	// example: name.namespace:http:env=prod;env=test,version=my-v1
@@ -313,41 +444,3 @@ func ParseServiceKey(s string) (hostname string, ports PortList, tags TagsList)
 	}
 	return
 }
-
-func (t Tags) String() string {
-	labels := make([]string, 0)
-	for k, v := range t {
-		if len(v) > 0 {
-			labels = append(labels, fmt.Sprintf("%s=%s", k, v))
-		} else {
-			labels = append(labels, k)
-		}
-	}
-	sort.Strings(labels)
-
-	var buffer bytes.Buffer
-	var first = true
-	for _, label := range labels {
-		if !first {
-			buffer.WriteString(",")
-		} else {
-			first = false
-		}
-		buffer.WriteString(label)
-	}
-	return buffer.String()
-}
-
-// ParseTagString extracts tags from a string
-func ParseTagString(s string) Tags {
-	tag := make(map[string]string)
-	for _, pair := range strings.Split(s, ",") {
-		kv := strings.Split(pair, "=")
-		if len(kv) > 1 {
-			tag[kv[0]] = kv[1]
-		} else {
-			tag[kv[0]] = ""
-		}
-	}
-	return tag
-}
diff --git a/model/validation.go b/model/validation.go
index fbb4140..500efbd 100644
--- a/model/validation.go
+++ b/model/validation.go
@@ -17,12 +17,9 @@ package model
 import (
 	"fmt"
 	"regexp"
-	"strings"
 
 	"github.com/golang/protobuf/proto"
 
-	multierror "github.com/hashicorp/go-multierror"
-
 	proxyconfig "istio.io/manager/model/proxy/alphav1/config"
 )
 
@@ -44,166 +41,6 @@ func IsDNS1123Label(value string) bool {
 	return len(value) <= dns1123LabelMaxLength && dns1123LabelRex.MatchString(value)
 }
 
-// Validate confirms that the names in the configuration key are appropriate
-func (k *Key) Validate() error {
-	var errs error
-	if !IsDNS1123Label(k.Kind) {
-		errs = multierror.Append(errs, fmt.Errorf("Invalid kind: %q", k.Kind))
-	}
-	if !IsDNS1123Label(k.Name) {
-		errs = multierror.Append(errs, fmt.Errorf("Invalid name: %q", k.Name))
-	}
-	if !IsDNS1123Label(k.Namespace) {
-		errs = multierror.Append(errs, fmt.Errorf("Invalid namespace: %q", k.Namespace))
-	}
-	return errs
-}
-
-// Validate checks that each name conforms to the spec and has a ProtoMessage
-func (km KindMap) Validate() error {
-	var errs error
-	for k, v := range km {
-		if !IsDNS1123Label(k) {
-			errs = multierror.Append(errs, fmt.Errorf("Invalid kind: %q", k))
-		}
-		if proto.MessageType(v.MessageName) == nil {
-			errs = multierror.Append(errs, fmt.Errorf("Cannot find proto message type: %q", v.MessageName))
-		}
-	}
-	return errs
-}
-
-// ValidateKey ensures that the key is well-defined and kind is well-defined
-func (km KindMap) ValidateKey(k *Key) error {
-	if err := k.Validate(); err != nil {
-		return err
-	}
-	if _, ok := km[k.Kind]; !ok {
-		return fmt.Errorf("Kind %q is not defined", k.Kind)
-	}
-	return nil
-}
-
-// ValidateConfig ensures that the config object is well-defined
-func (km KindMap) ValidateConfig(k *Key, obj interface{}) error {
-	if k == nil || obj == nil {
-		return fmt.Errorf("Invalid nil configuration object")
-	}
-
-	if err := k.Validate(); err != nil {
-		return err
-	}
-	t, ok := km[k.Kind]
-	if !ok {
-		return fmt.Errorf("Undeclared kind: %q", k.Kind)
-	}
-
-	v, ok := obj.(proto.Message)
-	if !ok {
-		return fmt.Errorf("Cannot cast to a proto message")
-	}
-	if proto.MessageName(v) != t.MessageName {
-		return fmt.Errorf("Mismatched message type %q and kind %q",
-			proto.MessageName(v), t.MessageName)
-	}
-	if err := t.Validate(v); err != nil {
-		return err
-	}
-
-	return nil
-}
-
-// Validate ensures that the service object is well-defined
-func (s *Service) Validate() error {
-	var errs error
-	if len(s.Hostname) == 0 {
-		errs = multierror.Append(errs, fmt.Errorf("Invalid empty hostname"))
-	}
-	parts := strings.Split(s.Hostname, ".")
-	for _, part := range parts {
-		if !IsDNS1123Label(part) {
-			errs = multierror.Append(errs, fmt.Errorf("Invalid hostname part: %q", part))
-		}
-	}
-
-	// Require at least one port
-	if len(s.Ports) == 0 {
-		errs = multierror.Append(errs, fmt.Errorf("Service must have at least one declared port"))
-	}
-
-	// Port names can be empty if there exists only one port
-	for _, port := range s.Ports {
-		if port.Name == "" {
-			if len(s.Ports) > 1 {
-				errs = multierror.Append(errs,
-					fmt.Errorf("Empty port names are not allowed for services with multiple ports"))
-			}
-		} else if !IsDNS1123Label(port.Name) {
-			errs = multierror.Append(errs, fmt.Errorf("Invalid name: %q", port.Name))
-		}
-		if port.Port < 0 {
-			errs = multierror.Append(errs, fmt.Errorf("Invalid service port value %d for %q", port.Port, port.Name))
-		}
-	}
-	return errs
-}
-
-// Validate ensures that the service instance is well-defined
-func (instance *ServiceInstance) Validate() error {
-	var errs error
-	if instance.Service == nil {
-		errs = multierror.Append(errs, fmt.Errorf("Missing service in the instance"))
-	} else if err := instance.Service.Validate(); err != nil {
-		errs = multierror.Append(errs, err)
-	}
-
-	if err := instance.Tags.Validate(); err != nil {
-		errs = multierror.Append(errs, err)
-	}
-
-	if instance.Endpoint.Port < 0 {
-		errs = multierror.Append(errs, fmt.Errorf("Negative port value: %d", instance.Endpoint.Port))
-	}
-
-	port := instance.Endpoint.ServicePort
-	if port == nil {
-		errs = multierror.Append(errs, fmt.Errorf("Missing service port"))
-	} else if instance.Service != nil {
-		expected, ok := instance.Service.Ports.Get(port.Name)
-		if !ok {
-			errs = multierror.Append(errs, fmt.Errorf("Missing service port %q", port.Name))
-		} else {
-			if expected.Port != port.Port {
-				errs = multierror.Append(errs,
-					fmt.Errorf("Unexpected service port value %d, expected %d", port.Port, expected.Port))
-			}
-			if expected.Protocol != port.Protocol {
-				errs = multierror.Append(errs,
-					fmt.Errorf("Unexpected service protocol %s, expected %s", port.Protocol, expected.Protocol))
-			}
-		}
-	}
-
-	return errs
-}
-
-// Validate ensures tag is well-formed
-func (t Tags) Validate() error {
-	var errs error
-	if len(t) == 0 {
-		errs = multierror.Append(errs, fmt.Errorf("Tag must have at least one key-value pair"))
-	}
-	for k, v := range t {
-		if !tagRegexp.MatchString(k) {
-			errs = multierror.Append(errs, fmt.Errorf("Invalid tag key: %q", k))
-		}
-		if !tagRegexp.MatchString(v) {
-			errs = multierror.Append(errs, fmt.Errorf("Invalid tag value: %q", v))
-		}
-	}
-	return errs
-}
-
 // ValidateRouteRule checks routing rules
 func ValidateRouteRule(msg proto.Message) error {
 	value, ok := msg.(*proxyconfig.RouteRule)
diff --git a/model/validation_test.go b/model/validation_test.go
new file mode 100644
index 0000000..ebb8b3e
--- /dev/null
+++ b/model/validation_test.go
@@ -0,0 +1,15 @@
+// Copyright 2017 Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package model
diff --git a/proxy/envoy/BUILD b/proxy/envoy/BUILD
index 3116b9e..046013e 100644
--- a/proxy/envoy/BUILD
+++ b/proxy/envoy/BUILD
@@ -39,5 +39,6 @@ go_test(
         "//model:go_default_library",
         "//test/mock:go_default_library",
         "@com_github_emicklei_go_restful//:go_default_library",
+        "@com_github_golang_protobuf//proto:go_default_library",
     ],
 )
diff --git a/proxy/envoy/config_test.go b/proxy/envoy/config_test.go
index 4014a7c..3364c34 100644
--- a/proxy/envoy/config_test.go
+++ b/proxy/envoy/config_test.go
@@ -15,11 +15,14 @@
 package envoy
 
 import (
+	"fmt"
 	"io/ioutil"
 	"reflect"
 	"sort"
 	"testing"
 
+	"github.com/golang/protobuf/proto"
+
 	"istio.io/manager/model"
 	"istio.io/manager/test/mock"
 )
@@ -251,8 +254,20 @@ func testConfig(r *model.IstioRegistry, envoyConfig, testCase string, t *testing
 	}
 }
 
+func configObjectFromYAML(kind, file string) (proto.Message, error) {
+	schema, ok := model.IstioConfig[kind]
+	if !ok {
+		return nil, fmt.Errorf("Missing kind %q", kind)
+	}
+	content, err := ioutil.ReadFile(file)
+	if err != nil {
+		return nil, err
+	}
+	return schema.FromYAML(string(content))
+}
+
 func addCircuitBreaker(r *model.IstioRegistry, t *testing.T) {
-	msg, err := model.IstioConfig.FromYAML(model.DestinationPolicy, cbPolicy)
+	msg, err := configObjectFromYAML(model.DestinationPolicy, cbPolicy)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -265,7 +280,7 @@ func addCircuitBreaker(r *model.IstioRegistry, t *testing.T) {
 }
 
 func addTimeout(r *model.IstioRegistry, t *testing.T) {
-	msg, err := model.IstioConfig.FromYAML(model.RouteRule, timeoutRouteRule)
+	msg, err := configObjectFromYAML(model.RouteRule, timeoutRouteRule)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -275,7 +290,7 @@ func addTimeout(r *model.IstioRegistry, t *testing.T) {
 }
 
 func addWeightedRoute(r *model.IstioRegistry, t *testing.T) {
-	msg, err := model.IstioConfig.FromYAML(model.RouteRule, weightedRouteRule)
+	msg, err := configObjectFromYAML(model.RouteRule, weightedRouteRule)
 	if err != nil {
 		t.Fatal(err)
 	}
-- 
2.11.0

